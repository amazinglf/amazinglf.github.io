
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="1、cocoapods概念 用来方便的统一管理项目中引用的第三方库的工具，它的原理是将所有第三方的依赖库放到https://github.com/CocoaPods/Specs远程仓库的pods项目中，让使用cocoapods的项目依赖这 个pods 项目来管理它所引用的第三方库， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://amazinglf.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="amazinglf.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/27/cocoapodsshi-jian/">CocoaPods实践</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-11-27T18:26:33+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>6:26 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、cocoapods概念</p>

<pre><code>   用来方便的统一管理项目中引用的第三方库的工具，它的原理是将所有第三方的依赖库放到https://github.com/CocoaPods/Specs远程仓库的pods项目中，让使用cocoapods的项目依赖这 个pods 项目来管理它所引用的第三方库，即使用这个工具将本地项目对第三方库管理的职责转移出去。
</code></pre>

<p>2、cocoapods安装和使用</p>

<pre><code>安装常用命令如下：
ruby -v    //查看当前ruby的版本
sudo gem update --system //升级gem
gem sources -l    //查看ruby镜像的位置，看是否指向http://   ruby.taobao.org/，具体原因可打开链接
sudo gem install cocoapods   //下载安装CocoaPods
pod setup


使用方法：
  （1）终端中，cd到项目总目录，创建podfile文件，指定项目需要依赖的第三方库
  （2）使用pod search &lt;&gt;命令,可以预先查找自己需要的第三方库资源
  （3）创建好podfile文件后，执行pod install ／pod install --verbose命令，执行安装第三方库的操作。如果前面命令的执行速度非常慢，可以使用pod install --verbose --no-repo-update命令替 换，该命令的作用是不把cocoapods远程仓库上的podspec索引文件更新到本地
   (4)  命令执行成功之后，会生成几个新的文件，一定要注意先关闭xcode，此时需要直接打开新生成的.xcworkspace来打开项目了，否则会报错
  （5）如果修改了podfile文件，执行pod update命令即可
</code></pre>

<p>3、podspec文件的作用</p>

<pre><code>  （1）cocoapods上所有第三方库的项目都对应有一个podspec文件，放置在https://github.com/CocoaPods/Specs仓库上，第一次执行pod setup时，就会将这个仓库上所有的这些podsepc索 引文件下载到本地的~/.cocoapods/目录下。
  （2）我们也可以为自己的项目创建podspec文件，不放到cocoapods公有的远程仓库上，放到自己私有的某个git仓库上，只作为本地私有pods使用，创建好之后，其他项目就可以通过指定podspec文件信息来使用本地私有的公 共库，在podfile文件中，添加如下信息。  pod 'LfDemoCode', :podspec =&gt;'http://git.XXX.com/users/liangfang/repos/testlf/LfDemoCode.podspec'
</code></pre>

<p>4、podfile.lock文件的作用</p>

<pre><code>  （1）该文件用于在多人协作开发中，锁定项目中各个依赖库的版本，如果有人多次执行pod install不会更改版本，但是执行pod update就修改podfile.lock文件了，因为，在多人协作开发时，会将 该文件纳入版本控制中，如果有人修改了这个文件，大家都可以同步。
</code></pre>

<p>5、创建cocoapods私有库方法</p>

<pre><code>   通过cocoapods创建自己的私有库，在公司内部供其他项目使用，首先需要具备如下条件：

  （1）创建一个私有的git远程仓库，类似于cocoapods的https://github.com/CocoaPods/Specs仓库，它的作用就是用于存放依赖库的podspec文件，称之为Spec Repo。然后在本地把这个仓库 添加为一个pod repo，在终端执行如下命令：
   pod repo add LFSpecs ssh://git@git.XXX.com/~liangfang/lfspecs.git,其中LFSpecs是指定的私有repo的名字，命令执行成功后，就可以在本地的~/.cocoapods/repos目录 下，看到添加的这个repo的文件夹(这里还看不到文件夹下相应的podspec文件,因为还没有push相应文件)，其他人如果要共用这个repo上传他们的库文件的话，执行相同的命令即可，即也可以在本地push自己的podspec文件。

   （2）创建一个管理项目工程文件的版本控制地址，git仓库或者其他仓库地址都可以，用来存放依赖库实际代码的项目文件，方式一、使用自己已经创建好的现成的一个项目，push到这个版本 控制地址，方式二、使用pod提供的一个命令开始创建项目，如pod lib create LFPodTestLibrary，其中LFPodTestLibrary是指定的项目名字，然后再push到这个版本控制地址。这里主要考虑第一种方式的使用。具体步骤如下：

     第一步：在本地创建一个工程项目PracticeForPodProject，cd到这个工程目录下，执行git init，添加一个远程管理仓库，提交代码到这个仓库
     git remote add origin ssh://git@git.XXX.com/~liangfang/customcreatepodproject.git
     git push origin master 
     这里需要注意的是要保证打开git网址直接打开工程项目的所有文件，不要在所有文件外面再包含一层文件夹，因为pod spec lint验证的时候会报找不到source file文件的错误。一开始我是先git clone远程仓库地址，然后在这个文件夹下创建新的工程文件，就会有一个以工程名命名的总文件夹，这样就出现上面一直验证不通过的问题。

    第二步：创建一个podfile文件，如下所示，添加一些第三方依赖，保存后执行pod install, 成功之后，把相关修改提交到仓库。使用下面的命令给这个项目添加一个tag号：git tag -m “first release”  0.0.1 ,然后使用命令 git push —tags 来推送tag到远程仓库。

source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'
pod 'ReactiveCocoa', '~&gt; 2.4.2'
pod 'Mantle', '~&gt; 2.0.4'
pod 'SVProgressHUD-0.8.1', '~&gt; 0.8'
pod 'Masonry', '~&gt; 0.6.2'

   第三步：给这个项目添加一个podspec文件，可使用如下命令进行创建：
   pod spec create PracticeForPodProject git地址。
   执行完后就创建了一个podsepc文件，指定git仓库地址,修改相关内容如下, 注意相关信息与前面定义的保持一致，在本地工程主目录下，创建Pod文件夹，以及Pod下的Classes Assets子文件夹，存放相关测试的.h .m 文件。同时从其他项目拷贝一个license文件和readme.md到当前工程主目录下。保存修改的podspec文件，将前面的所以修改先提交到远程仓库，尤其是添加的文件夹以及使用最新的tag号指向你提交到远程的最新版本，然后执行pod lib lint 以及 pod spec lint PracticeForPodProject.podspec .查看验证是否通过，可以加上--no-clean查看具体信息。

 Pod::Spec.new do |s|
 s.name         = "PracticeForPodProject"
 s.version      = "0.0.1"
 s.summary      = "A test for PracticeForPodProject."
 s.description  = &lt;&lt;-DESC
               A test  for PracticeForPodProject in Markdown format.
               DESC
 s.homepage    = "http://git.XXX.com/users/liangfang/repos/customcreatepodproject/browse"
  s.license      = "MIT"
  s.author             = { "liangfang" =&gt; "liangfang@163.com" }
  s.platform     = :ios, "9.0"
  s.source       = { :git =&gt; "ssh://git@git.XXX.com/~liangfang/customcreatepodproject.git", :tag =&gt; "0.0.1" }
  s.source_files  = "Pod/Classes/**/*.{h,m}"
 end

 第四步：在第三步podspec文件验证通过之后，要把所有修改提交到远程仓库，同时还要把podspec文件提交到远程的spec repo,使用如下命令：
pod repo push LFSpecs PracticeForPodProject.podspec //LFSpecs即为前面创建的repo的名字，文件内容中相关字段可参考http://guides.cocoapods.org/syntax/podspec.html#specification。
 提交成功之后，就可以在本地~/.cocoapods/repos目录下以及LFSpecs对应的远程仓库上找到相应podspec文件。通过pod search PracticeForPodProject也可以找到相应工程信息。

 第五步：修改本地的podfile加上如下语句，执行pod install，再重新打开项目工程，就可以看到前面创建的Pods/Classes/.h .m,已经存放到Pods工程的Development Pods/PracticeForPodProject目录下了。每次在Pods工程下新添加了文件，主要要提交到远程仓库。操作方式与前面类似，方便其他项目对他的依赖。

  source 'ssh://git@git.XXX.com/~liangfang/lfspecs.git'
  pod "PracticeForPodProject", :path =&gt; "PracticeForPodProject.podspec"


   （3）下面在一个本地的其他项目中，来测试上面的项目是否可以通过cocoapods来使用，可通过在podfile文件中添加如下语句，如下所示：执行pod install ，再打开项目就可以在Pods工程中的Pods目录下找到依赖的本地的PracticeForPodProject工程

source 'ssh://git@git.XXX.com/~liangfang/lfspecs.git'
pod "PracticeForPodProject", :git =&gt; 'ssh://git@git.XXX.com/~liangfang/customcreatepodproject.git', :commit =&gt; 'd2804be542c'

   （4） 在其他项目中也可以通过 pod ‘PracticeForPodProject’, ‘~&gt;1.0’ 来直接添加了
   （5）关于cocoapods的subspec属性的使用，后面再添加,如果修改了pod里面已存在的文件，不需要pod install，如果新添加了文件需要pod install.
</code></pre>

<p>参考链接</p>

<p><a href="http://objccn.io/issue-6-4/">http://objccn.io/issue-6-4/</a>
<a href="http://guides.cocoapods.org/syntax/podfile.html">http://guides.cocoapods.org/syntax/podfile.html</a>
<a href="http://www.cocoachina.com/ios/20150916/13384.html">http://www.cocoachina.com/ios/20150916/13384.html</a>
<a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/">http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/</a>
<a href="http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/</a>
<a href="https://guides.cocoapods.org/">https://guides.cocoapods.org/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/01/swift-xue-xi-zong-jie/">Swift 学习总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-01T14:33:03+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2016</span></span> <span class='time'>2:33 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Swift学习之基础部分
常量和变量,主要掌握根据它们使用的场景，对不会变化的值使用常量，对不断变化的值使用变量。</p>

<p>注释：单行注释使用//，多行注释使用/<em>  </em>/，对于多行注释还可以使用嵌套。</p>

<p>分号：Swift中可以省略分号，如果在同一行有多条语句，需要用分号隔开。</p>

<p>整数：Int UInt 可以通过它的最大值、最小值属性获取它表示的范围。</p>

<p>浮点数：带有小数点的数据类型，Float Double。</p>

<p>类型安全和类型推断：Swift会在编译的时候对代码进行类型检查，把不匹配的类型标记为错误。如果给变量或常量赋了初始值的时候，可以不申明类型，由系统进行类型推断。</p>

<p>1、基础数据类型（本质都是通过结构体或枚举类型定义的）
  常量定义 let  i ＝ 10，常量一般必须要赋一个初值
  变量定义 var j : Int ，变量如果指定类型可以不赋初值,如果没有指定类型必须赋初始值
  它们的共同特点就是可以不指定值的类型。如果没有指定类型编译器会根据你赋的值进行类型推断。
  总结：Swift支持隐式类型推断，不支持隐式类型转换（把某种类型的值赋值给另一种类型的值）。</p>

<p>2、swift新增的数据类型
  元组（tuples)
  可选值
  隐式解析可选</p>

<p>3、字符串数据类型
  首先理解字符串存储由来，我们都知道计算机只能识别0101的数字，那一些非数值类型的字符是如何存储的呢，首先需要制定一些统一的标准，将符号转化为数字，由此出现针对英文字符的ASCII编码，但是全世界除了英文，还要中文，俄文等等其他语言，ASCII编码已经不能满足我们的需求，因此出现一个支持全世界各种语言的国际标准Unicode标准，而swift就是支持Unicode标准的一门语言，并且它的变量名也是支持中文的。</p>

<p>4、运算符
   与其他语言的区别，一个赋值运算符整体构成的表达式不代表一个值，不能进行连续赋值a＝b＝1，并且赋值运算符也不能出现在if判断语句中了，如果出现就会报错，这样也能避免我们把==写成＝，而不报错的情况出现。
   还有另外一个区别，swift新增了一种区间运算符，定义如下：0&hellip;5 表示0，1，2，3，4，5。0&hellip;&lt;5 表示0，1，2，3，4。有一个需要注意左右区间不能用小数，否则会出现一直循环。</p>

<p>5、集合数据类型
  数组：相同类型的数据在数组中连续排列，因为是有序，元素检索速度非常快（c语言数组定义）。Swift数组的定义与此类似，还是有很多差别。定义如下：var array1 : Array<Int> = ［1,2,3,4］,因为数组中元素类型定义为范型，我们可以定义为任意一种类型。 并且Swift的数组中可以放置任意类型的数据。通过设置它的类型为Any，如下：var array1 : Array<Any> = ［“hello”,2,3,4］，至于它为什么能存储不同数据类型，可以从数组的结构体定义以及存储上去找原因。并且Swift允许在结构体中声明方法，更符合面向对象思想。
  数组操作：读数据，通过数组下标的方式，同样也要注意数组越界的问题。修改数据，前提数组是变量，可以通过append、insert等向数组中添加一个元素，或者以直接赋值的方式修改数组中某个元素，以及通过removeLast、removeAtIndex删除数组中的某个元素。
  slice：一种与数组非常相似的集合类型，定义也差不多一样，和数组可以进行相互转换，如：Slice sli = array1[0&hellip;5] 通过区间运算符或者使用Slice的结构体方法定义 Slice sli = Slice(array1)，不能直接赋值
 range：用来存放区间表达式的值，它的本质是结构体，它也支持泛型（即任意类型，但也必须遵守forwardindex协议），var range : Range<int> = 0&hellip;3 或者通过构造方法定义 var range2 : Range<int> = Range(start:0, end:3)，需要注意的是这里表示0，1，2，不包括3。而前面的定义包括3.
 数组批量操作，前面讲的slice、range都是为数组的批量操作做准备的。</p>

<p>  (1) 可以将range指定范围内的数替换成任意其他个范围内的数，var array1 = ［1,2,3,4］array1[0&hellip;1] = ［8,7,8,9]。最后得到的array1为:［8,7,8,9,3,4]。或者使用函数array1.replaceRange(Range(start:0, end:2), With:[8,7,8,9]).，实现和前面一样的结构
  (2) 数组还可以通过复合的赋值运算符往数组中添加元素、数组、slice等，array1+=9 等价于 array1.append(9)，array1+＝[1,2,3]，array1+=slice，array1+=array2[0&hellip;5]
  数组遍历，第一种for in 快速枚举，第二种通过元组进行遍历
for elem in array1{
  println(elem)
}
 for  (index, value) in enumerate(array1){
  println(&ldquo;index:(index) = (value)&rdquo;);    //其中(index)类似于对字符串中格式化占位符的处理
}</p>

<p>6、字典数据类型
基本概念，存放无序的数据，因此它的遍历需通过检索数据关键字实现，它类似于数据结构中hash函数和hash表的概念，首先根据key和hash函数计算出一个地址，addr = hash(key)，然后从hashtable中根据这个地址获取到key对应的值，value ＝ hashtable(addr)。所以key首先是必须可hash的，在swift中可hash，即需要遵守一个协议，一般的基本数据类型string、int、float等都遵守相应协议，因此，一个字典中它的key值也可以是多样的。 如：var dict ＝ ［”1“:a，2:b]
字典操作，读：println(dict[&ldquo;1&rdquo;])  写：dict[2] = 8 修改：dict.updatevalue(9,forkey(&ldquo;1&rdquo;))。需要注意修改操作返回的是一个可选值，如果key存在，会替换key对应的值，并且返回key对应的之前的值，如果key不存在，会向字典中增加一个这个不存在key所对应的值，相当于往字典中添加了一个新的值，并且返回nil。删除：dict.removevalueforkey(&ldquo;1&rdquo;)，同样，如果存在这个key，就删除相应key对应的值，同时返回旧的value值，如果不存在这个key旧不做任何操作，返回nil。字典遍历，即类似元组遍历，同时也可以遍历所有key，或者所有value
if let orignal = dict.updatevalue(9,forkey(&ldquo;1&rdquo;)){
println(&ldquo;new:(dict["1&rdquo;])&ldquo;);
println(orignal);
}
if let orignal = dict.removevalueforkey("1&rdquo;){
println(original)
}
for (key,value) in dict{
println(&ldquo;(key):(value)&rdquo;)
}
for key in dict.keys{
print(key)
}
for value in dict.values{
println(value)
}</p>

<p>7、swift中语句的基本用法
if语句，以及if中多分支执行语句，我们知道程序不可能只有一种执行顺序，因为实际生活中往往存在多种选择或者循环问题，下面从程序指令执行过程的角度考虑：
顺序指令：比较好理解，选择指令：有些指令被执行，有些指令不会执行，循环指令：某些指令会循环不断的被执行。将这三种指令相结合，可以解决我们实际生活中的绝大部分问题。
其中if else、while、for in、break、continue语句的使用与OC语言都非常相似，要特别注意的是switch语句与其他语言的switch语句有一些差别，主要区别为三点，（1）最后必须加default （2）可以去掉break了，oc中如果case语句后面不加break，会造成switch贯穿执行，即匹配到某一个case选项后，后面的所以case的语句都会被执行，而在switch中，不需要显示添加break，它匹配到case后，会自动退出。（3）case后面可以添加多个匹配条件，如case “a",&ldquo;b&rdquo; 类似于或，只要有一个满足要求即可。（4）因此，switch支持广义匹配，匹配类型可以是整形、区间运算符、元祖、通配符（如<em>，表示任意一个字符），实例如下。（5）switch具有值匹配模式特性，在第三个例子中，case中的let x let y表示：x y可取任意值，一旦有值，会把它绑定到x y中，赋给x y，x y页可以为常量，［let x， let y］与［let（x，y）］两者的写法是等价的。在case匹配语句使用值绑定的情况下，可以在后面加上where条件，加上值绑定模式的匹配条件。
let x = 1000 ｛
 case 1&hellip;9 :
   println(&ldquo;个位数&rdquo;);
 case 10&hellip;49:
  println(&ldquo;十位数&rdquo;)
 default:
  println(&ldquo;不符合&rdquo;)
｝
let point = (10,10)
switch point ｛
  case (0,0) :
   println(&ldquo;坐标原点&rdquo;)
 case (1&hellip;10, 1&hellip;10) :
   println(&ldquo;x,y坐标位于1-10之间&rdquo;)
  case(</em>, 0) : <br/>
   println(&ldquo;点在x轴&rdquo;)
  default :
   println(&ldquo;其他&rdquo;)
｝
swith point ｛
 case (let x ,10)
  println(x)
case let(x, y)
  println(&ldquo;(x):(y)“）
case let x, let y
  println(&rdquo;(x):(y)“）
case let (x, y) where x == -y
  println(&ldquo;(x):(y)“）
//返回两个顶点的长和宽
let po = (double, double) = (0,0)
let p1 = (double, double) = (8,8)
fun getlengthandwidth(p0:(double,double), p1(double,double)) -> (length:double, width:double) ｛
   return (abs(p0.0-p1.0), abs(p0.1-p1.1))
}
let w = getlengthandwidth(p0, p1).width
let h = getlengthandwidth(p0, p1).length
//这里要通过名称访问元祖的某个元素，要定义返回值元组中每个元素的名称</p>

<p>8、函数的相关概念
定义：完成某个特定功能的代码块，该代码块可重复使用。
语法：func 函数名(参数名:参数类型,参数名:参数类型,&hellip;) -> 函数返回值类型 ｛      //函数实现部分      ｝   <br/>
调用语法：函数名（实际参数&hellip;）   函数名遵循驼峰命名法 ，可以有多个参数，多个返回值，也可以没有参数没有返回值（没有返回值时，可以不写->,或者写-> void）。实例代码如上面第四个例子所示，
内部参数与外部参数概念：因为函数的定义实现与函数的调用是分开的，因此当我们看到某个函数调用的代码或者想要调用某个函数时，希望通过参数名就可以了解传递参数的含义，而不用去看函数的定义和实现。因此swift提供了一个外部参数，我们在调用函数的时候可以显示对这个外部参数赋值，这样函数的参数信息一目了然。类似于oc中通过方法名帮助我们理解参数含义，</p>

<p>swift中则通过外部参数帮助我们理解函数传入参数的含义，实例代码如8-1所示，注意：函数实现部分，只能使用内部参数。如果内部参数和外部参数想使用同一个名字，即一个参数即表示内部参数又表示外部参数，可在参数名前面加上＃，进行标识</p>

<p>如果你不设置函数的外部参数名，但是调用函数的时候默认会把内部参数名作为外部参数名，但是第一个参数不会，如下所示
func test(first:Int, second:Int)
{
   print(&ldquo;hello&rdquo;);
}
test(1, second: 2)
如果想在调用函数的时候想省略第二个外部参数名，即加上下划线_即可
如下所示
func test(first:Int, _ second:Int)
{
   print(&ldquo;hello&rdquo;);
}
test(1, 2)</p>

<p>下面是一些实例代码
8-1
8-2
8-3</p>

<p>func divisionoperation(dividend a:double, divisor b:double) -> double ｛
  return a/b
}
let res = divisionoperation(dividend:3.5, divisor:1.2)
func joinstring(s1:string, tostring s2:string, joiner s3:string = &ldquo;#&rdquo;) -> string ｛
  return s1+s2+s3
}
let str = joinstring(&ldquo;hello&rdquo;, tostring:&ldquo;world&rdquo;)
func swap(a:int, b:int){
let t = a
a = b //这里会报错
b = t
}</p>

<p>   函数默认值参数概念：即对函数中的某个参数指定默认值，相应在调用时可以不给这个默认值参数赋值，有一个需要注意的：当带有缺省值或默认值的这样一个参数，如果只有一个参数名，内部参数名将作为外部参数名使用，因为调用函数，修改其参数默认值，必须使用其外部参数名，否则报错，因此，在函数默认值参数的定义中，如果只定义了内部参数名，没有定义外部参数名，编译器会把默认值参数的内部参数名当作外部参数名使用，这属于编译器做的一个优化，实例代码如8-2所示，注意：对比c++中默认参数必须写在函数参数列表最尾部，不能移到参数列表前面，但是swift中现在是可以的，即可以出现在参数列表的任一位置。
    常量参数与变量参数概念：默认函数的参数是常量类型，即只可以读，不可以写或者进行修改操作，如图8-3的使用，编译器会报错，我们可以把它定义为var类型，就可以修改了inout参数的使用：主要用在输入输出函数中，首先看8-4的代码,调用 swap(x,y)之后，最后的输出结果x还是10，y还是28，我们一般会认为x y值应该变化，其实并没有，它实际执行是将10赋值给a，19赋值给b，实际只修改了a b，没有修改x y，在c语言中也同样存在这样的问题，c语言的处理方式是可以 传递x y变量的地址，相应在swap函数中申明a b为指针。但是swift中没有指针，因此引入了一个inout关键字，通过这个关键字修饰参数。改进后的代码如8-5所示：注意：调用swap函数使用&amp;符号不是c语言中取地址的含义，而是将x y变量赋值给函数a b参数。总结：如果我们希望一个函数能修改外部的变量，首先在函数定义时需把参数定义为inout，输入输出参数类型，其次传递实参时需在变量前面加一个&amp;的形式传递过去，等价于a是x的引用，b是y的引用，传递的时候是把x y整个变量都传递过去，而不只是传递变量对应的值10 28，通过&amp;x &amp;y与inout a inout b的配合，最终达到修改函数传递参数的目的。注意：符号&amp;后面不能直接跟一个具体值，需要传一个变量名。
8-4
8-5
8-6
8-7
8-8
func swap(var a : int, var b : int){
let t = a
a = b
b =t }</p>

<p>var x = 10
var y =  28
swap(x,y)
 func swap(inout a : int, inout b : int){
let t = a
a = b
b =t }</p>

<p>var x = 10
var y =  28
swap(&amp;x,&amp;y)
func add (array : [int] -> int ｛
var sun = 0
for i in array ｛
 sum +=i
}
println(add([1,2,3,4,5]))
for array(array : int&hellip;) -> int ｛
var sum = 0
for i in array ｛
 sum += i
｝
println(add(2,3,4))
fun add (a:int, b:int) -> int ｛
return a+b
｝
fun sub (a:int, b:int) -> int ｛
return a-b
}
     变参参数，即参数个数可以是不确定的，要实现变参参数，我们首先想到的可能是通过数组的形式实现，如8-6实例代码所示，在swift中对变参参数进行了定义，语法格式为，参数名：参数类型&hellip;  ,只需要修改变量类型，即在参数个数不确定，但是参数类型都是一致的情况下可以这样使用，即把它当作一个数组（集合），并且 在调用时不用传数组，而是像调用函数一样，传递任意个相应类型的参数，如8-7所示，函数实现不变，并且在调用函数时做一些修改即可。注意：变参函数中变参必须放在参数列表最后面。
函数类型：（参数、返回值类型）类型相同的函数定义如下：函数参数类型以及返回值类型都一样只是实现不一样。如8-8所示，可以将上面的两个函数抽象出公共的函数类型（int, int) -> (int)，可以对这个函数类型做如下的一些定义。
     定义一个函数类型常量或变量：var calfunc: (int, int) -> int = add，这样非常类似c语言中函数指针以及oc中的block，申明这样一个变量有一个好处即可以对它重新赋值，calfunc = sub println(calfunc(3,5)，此时得到是sub函数计算的结果。因为一个函数类型的变量非常灵活，它可以指向相同类型的其他函数，可以达到c语言中函数指针及oc中block一样的功能。
函数类型作为一个参数，如8-9所示，将其关联。
8-9
8-10
9-1
9-2</p>

<p>func subcalfunc(a:int, b:int, #op:(int, int) -> int) ｛
return op(a, b)
}
println(subcalfunc(20.35,op:sub)
func max(a: int, b:int) -> int ｛
return a>b?a:b
｝
func min(a:int, b:int) -> int ｛
return a>b?b:a
｝
func choosefunc(#getmax:bool ) -> (int, int) -> (int)｛
return getmax?max:min
｝
var myfunc:(int, int) -> (int) = choosefunc(getmax:true)
println(myfunc(2,9))
func funcname(参数) -> 返回值类型 ｛
执行语句
｝
｛ （参数) -> 返回值类型 in
执行语句
｝
let sayhello:() -> void = ｛
println(&ldquo;hello word&rdquo;)
}  //无参闭包，() -> void可以不写
sayhello()
let add:(int, int) -> (int) = ｛
(a:int , b:int) -> int in
return a+b
}   //有参闭包，
println(add(3,5))</p>

<p>函数返回一个函数类型的返回值：当根据输入参数判断执行哪一个函数时使用，如8-10所示</p>

<p>9、闭包的基本概念
   闭包：从函数的定义来理解，完成某个特定功能的代码块，在swift中可以理解为闭包是一个更轻量级的函数（自包含的函数代码块），可以把函数分为三大类（1）全局函数（有名函数）。（2）闭包表达式（匿名），能捕获上下文中的常量或者变量，牵涉到内存管理，值捕获。(3)嵌套函数。</p>

<p>   闭包表达式的定义、申明和使用，与函数的区别，闭包没有函数名，但是它还是由参数类型和返回值类型构成，并且参数类型和返回值类型是写在大括号里面的，并且还有注意加一个关键字in，如果没有参数和返回值可以不加in，如9-1所示，上面是函数定义，下面是闭包定义。理解闭包表达式它实际也是有类型的， 在swift中很多都可以称之为一个类型，而类型又可以定义一些常量或变量。如9-2所示。上面的用法只属于非典型性用法，因为这些用法跟函数的使用还没有很多区别。</p>

<p>   闭包表达式的回调用法：即闭包比较典型的用法，下面9-3是一个冒泡排序的实例代码，对它进行改造，将array[j] > array[j+1]的比较通过闭包实现，假设这个比较需要处理比较多的内容，得到9-4所示代码，在9-4的bubbleSort2(&amp;array, intCmp)方法中，还可以把intCmp方法的实现代码直接移过来，不定义为变量。如果要修改比较策略，譬如字符串比较，数字最低位比较，可以只修改闭包函数。类似于block回调，我们可以定义多种block函数的实现，调用bubblesort只需要告诉它一个排序数据以及排序策略。相比于函数来说，闭包可以省略函数名，直接函数实现。通过闭包、block实现多种变化的功能，我们可以传递闭包表达式的多种不同实现，至于闭包表达式何时被调用，是由外层的函数决定的。
9-3
9-4
9-5
9-6
func showArray(array:[Int]){
    for x in array{
        print(&ldquo;(x)&rdquo;)
    }
    print(&ldquo;&rdquo;)
}</p>

<p>func bubbleSort(inout array:[Int]){
    let cnt:Int = array.count
    for var i = 1; i &lt; cnt ; i++ {
        for var j = 0; j &lt; cnt - i; j++ {
            if (array[j] > array[j+1]){
                let t = array[j]
                array[j] = array[j+1]
                array[j+1] = t
            }
        }}
}</p>

<p>var array = [6,5,9,3,5,2,10]
showArray(array)
bubbleSort(&amp;array)
showArray(array)
let intCmp = { (a:Int,b:Int) -> Int in
    if a > b {
        return -1
    } else if a &lt; b {
        return 1
    } else{
        return 0
    }
}</p>

<p>func bubbleSort2(inout array:[Int]){
    let cnt:Int = array.count
    for var i = 1; i &lt; cnt ; i++ {
        for var j = 0; j &lt; cnt - i; j++ {
            if (intCmp(array[j], array[j+1]) == -1){
                let t = array[j]
                array[j] = array[j+1]
                array[j+1] = t
            }
        }
    } }
showArray(array)
bubbleSort(&amp;array)
bubbleSort2(&amp;array, intCmp)
showArray(array)</p>

<p>bubbleSort2(&amp;array, {
    (a,b) in
    if a > b {
        return -1
    } else if a &lt; b {
        return 1
    } else{
        return 0
    }
})</p>

<p>bubbleSort2(&amp;array, {
    if $0 > $1 {
        return -1
    } else if $0 &lt; $1 {
        return 1
    } else{
        return 0
    }
})
sort($array,{
    return $0 &lt; $1
})
sort($array,{
  $0 &lt; $1
})
9-6-1
func bubbleSortFunc(inout array: [Int]){
    let cnt = array.count
    func swapValue(inout a:Int, inout b:Int){
        let t = a
        a = b
        b = c
    }
    &hellip;.
}
9-6-2
func getIntFunc(inc :Int) -> (Int) -> (Int){
    func incFunc(v: Int) -> Int{
        return inc + v
    }
    return incFunc
}
 9-6-3
let incFunc1 = getIntFunc(12)
print(incFunc1(15))
func getIncFuc(inc : Int) -> (Int) -> (Int){
    var mt = 20
    func incFunc2(v:Int) -> Int{
        mt++
        return inc + v + mt }
    return incFunc2
}</p>

<p>   闭包表达式的语法优化：为什么要优化，如何优化，借用swift强大的类型推断功能，实现闭包表达式类型优化，  （1）在函数中传递闭包表达式时省略类型，前提是函数申明中包含了闭包类型时，可以根据上下文推断，省略闭包参数类型及返回值类型。如9-5所示，（2）进一步优化，参数都可以省略，而是使用$0 $1来代替，如9-5下面所示</p>

<p>   尾随闭包：由于闭包表达式主要用于函数回调，在函数调用时，为了表达更清楚，书写更方便，应该将闭包作为函数最后一个参数，即尾随闭包。当闭包的执行语句，只有单个return表达式的情况下，可以简写去掉return，如9-5下面的代码所示。</p>

<p>   嵌套函数：在函数内部申明一个函数，并且这个内部函数只能在内部使用，即它的作用域是在内部函数左右开始，往下到它所在函数结束的位置，同时函数通过闭包捕获上下文的值也属于嵌套函数。如9-6所示，嵌套函数仅仅为它所在的函数服务，所以有一个优点就是可以让程序更直观更清楚。</p>

<p>   闭包捕获值定义：嵌套／内部函数可以引用不是它自己而是它所在外部函数申明的变量或常量，因此我们需要研究它捕获的原则，捕获的行为。在9-6-2的实例代码中，定义了一个嵌套函数，我们知道在函数内部申明的局部变量它的作用域和生命周期只在调用函数的时候有效，函数调用结束就不生效了，但是在上面这种情况下，inc被返回的嵌套函数保留了，我们可以暂时理解为一个副本，这个过程可理解为一个上下文的捕获。从内存管理和函数调用栈的角度考虑，一般认为inc随着函数getIntFunc的调用结束已经没有了，但是嵌套函数中使用了inc局部变量，我们就称之为值捕获，从9-6-3的例子中，会发现每次调用这个函数，返回值都会加1，说明嵌套函数捕获mt后，相当于拷贝了mt的一个副本，会记录mt上一次的值，我们可以理解为mt相当于incFuc的一个全局变量，我猜想如果mt是self，不做保护措施，就会出现循环引用啦。</p>

<p>   泛型：可以创建泛型的函数或者类型，之前对泛型的了解只停留在它的使用，对于如何自己去自定义一个泛型没有想过，看了文档上的例子也还不是太理解，后面还要多看看。以
func swapTwoValues<T>(inout a: T, inout b: T) {} 这个函数为例,通过<T> 占位类型名 同时指定函数参数的类型，在调用的时候直接传入一个任意类型即可。如果需要传入多个占位类型，可以用逗号隔开，进行如下表示 &lt;T,T>。数组是非常典型的泛型函数，它支持任意类型，现在如果自定义一个特定的数组：栈，就需要使用泛型函数了。</p>

<p>   协议和扩展：主要使用关键字protocol和extension来进行定义，它的使用和oc语言差不多（在语法定义上有一些差别，并且swift继承某个类和使用协议的语法是一样的在 : 后面，感觉这样不是很好，只是推荐把父类写在前面），可以将协议名作为一种命名类型来使用的做法还不是很理解（现在理解了，可以把协议类型作为函数参数类型、返回值类型等用法，充分发挥协议的优势，可以灵活的创建和传递同一个方法的不同实现），文档上的例子也标注了这样使用的注意事项。为什么swift的协议中要申明属性呢，与以前只申明方法相比，申明属性有什么好处呢？通常理解实现了协议的类型，该类型中必须拥有协议中相应的属性和方法（即协议只关心必须要有某些属性和方法，不关心属性和方法的具体值和具体实现）。注意：在协议中使用class关键字申明的类属性和类方法，当枚举和结构体实现这个协议时，需要使用static关键字。且协议中的方法不支持默认参数值。</p>

<p>   理解扩展的使用场景：在无法修改源代码，或者修改已有类不可行的情况下，需要对已有的类、结构体、枚举、协议等进行扩展。也可以对协议扩展以及补充某个类型为协议类型。</p>

<p>   枚举和机构体：枚举与其他语言的一个区别是它可以定义方法，并且它的语法也有了一些变化。文档上说结构体和类的一个最大区别是结构体是传值，类是传引用，这个概念跟我之前的理解好像有偏差， 还要多看看。</p>

<p>   对象和类：对类的定义类似c语言有构造器（有继承关系的情况下，会做以下几步，1、设置子类的属性值，2、调用父类的构造器，3、还可以改变父类定义的属性值等等）和析构函数，创建类的时候不需要标准根类，与oc语言的区别。子类重写父类的方法需要用override标记。可以在类中定义属性的getter和setter方法，注意它的语法格式。同时swift中还多了一个willset和didset的方法概念。方法与函数有一个重要区别，方法的参数名（除了第一个参数以外的其他参数名）需要在调用的时候显示说明，最后提到如何处理变量的可选值，看起来感觉有些怪，这个还要多看看。</p>

<p>   函数和闭包；可以通过元组让一个函数返回多个值。并且函数参数可以是一个可变参数（numbers: Int&hellip;) ，在函数内部使用时类似于数组。函数可以嵌套，可以作为另一个函数的返回值，可以作为另一个函数的参数。
可以使用{}来创建一个匿名闭包，使用in将参数和返回值类型申明与闭包函数体进行连接。闭包在很多种情景下可以进行一些简化，如单个语句的闭包可以省略参数返回值类型申明以及in关键字，
可以使用参数位置$0 $1来直接引用参数。当闭包作为某个函数的最后一个参数时，可以直接跟在括号后面。</p>

<p>   控制流：相比于oc，有一些简化，如if后面的条件和for循环变量括号可以省略，但是语句体的大括号是必须的。有一个问题不是太明白，if语句后面必须跟一个布尔表达式，那为什么可以使用
if let name = optionalName ｛｝这样的类似语法处理值缺失的情况，其中var optionalName: String? = &ldquo;hello"是一个可选值。 swift中的switch相对于其他语言更加强大，可以支持任意类型的数据以及各种比较操作。并且它可以省略break语句，但是一定不能省略default。
可以使用for in 加上元组来遍历一个字典。在循环中可以使用1..&lt;n表示范围，但是不包括上界，使用1&hellip;n才包括上界</p>

<p>相关参考：</p>

<p><a href="http://special.csdncms.csdn.net/the-swift-programming-language-in-chinese/index.shtml">http://special.csdncms.csdn.net/the-swift-programming-language-in-chinese/index.shtml</a>  中文的</p>

<p><a href="https://itunes.apple.com/cn/book/the-swift-programming-language/id881256329?mt=11">https://itunes.apple.com/cn/book/the-swift-programming-language/id881256329?mt=11</a> 英文的</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/20/mvvmkuang-jia-xue-xi-shi-jian/">MVVM框架学习实践</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-20T17:54:08+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:54 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>1、mvvm基本概念</h2>

<pre><code>   在MVC框架的基础之上，将view和view controller联系在一起作为一个整体，同时新建一个视图模型层view model，负责view和view controller这个整体与model层之间的通信。同时将原来ViewController中放置用户输入验证逻辑、视图显示逻辑、发起网络请求和其他各种各样的耗时操作放到 view model中。在MVVM框架的基础之上，再结合RAC响应式编程，通过在控制器层对模型层数据的绑定，来实现界面与模型层之间的数据交换。
</code></pre>

<h2>2、mvvm层次结构</h2>

<pre><code>     MVVM主要分为一下几层，
     model层：数据模型层
     view(view和view controller)层：显示自定义视图和和管理视图的控制器层
     view model层：连接model层和view层之间的桥梁，主要负责一些业务逻辑操作
</code></pre>

<h2>3、mvvm使用场景</h2>

<pre><code>（1）结合RAC简化自定义view与model层之间数据交互在控制器中使用RAC、RACObserver宏对view中要展示数据与view model层获取的model层数据进行绑定。
  使用RACCommad来响应界面的交互，具体步骤如下：
  第一步：在自定义view中定义一个command，在子view点击操作中执行这个command，excute：可以看看官网文档上它的用法

  第二步：在controlller中，把它与自定义view中的相应command进行绑定。在绑定的时候就实现这个commad的具体操作。

  第三步：也可以在controlller中定义这个commad属性。在属性的set方法中返回它的具体实现，最后不能忘记还要对这个commad与自定义view中的相应command进行绑定。

  第四步：commad的执行一般分以下几种状态：正在执行、执行失败、执行完（可以返回一个数据，但是一般通过修改某个与view进行绑定的数据之后，就可以自动通知view界面进行修改了，所有不返回数据也是可以的）

  （2）将UITableView上的数据源（实现&lt;UITableViewDataSource&gt;协议及其方法的类）分离出来，放到vm层。这样使得代码逻辑更清晰，且更有利于做单元测试。如果设置M层，还可以对代码做进一步的改进。
               实例代码如下所示：
</code></pre>

<p> VM层</p>

<pre><code>//声明一个block类型
typedef void (^TableViewCellConfigureBlock)(id cell, id item);
 //声明TableDataSource 类，实现UITableViewDataSource协议
@interface TableDataSource : NSObject &lt;UITableViewDataSource&gt;
 //定义一个实例化方法,设置数组、重用标识符，并调用相应block
- (instancetype)initWithItems:(NSArray *)anItems
           CellIdentifier:(NSString *)aCellIdentifier
       ConfigureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock;
 //根据indexPath返回item数组中的相应值
- (id)itemAtIndexPath:(NSIndexPath *)indexPath; 
@end



＃import “TableDataSource.h”
@interface TableDataSource ()
 //存放数据的数组
@property (nonatomic, strong) NSArray  *items;
 //重用标识符
@property (nonatomic, copy) NSString *cellIdentifier;
 //block对象
 @property (nonatomic, copy) TableViewCellConfigureBlock configureCellBlock;
 @end

 @implementation TableDataSource
 //自动生成get和set方法
 @synthesize items = _items;
 @synthesize cellIdentifier = _cellIdentifier;
 @synthesize configureCellBlock = _configureCellBlock;



 - (id)init {
return nil;
 }
- (instancetype)initWithItems:(NSArray *)anItems
           CellIdentifier:(NSString *)aCellIdentifier
       ConfigureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock
 {
self = [super init];
if (self) {
    self.items              = anItems;
    self.cellIdentifier     = aCellIdentifier;
    self.configureCellBlock = [aConfigureCellBlock copy];
}
return self;
 }


- (id)itemAtIndexPath:(NSIndexPath *)indexPath {
return _items[(NSUInteger)indexPath.row];
}
</code></pre>

<p>   pragma mark - UITableViewDataSource</p>

<pre><code>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
return 1;
 }

 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
return [_items count];
 }

 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:_cellIdentifier];
id item = [self itemAtIndexPath:indexPath];
 if (!cell) {
     cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:_cellIdentifier];
 }
//回调block。这个block是传进来的，所有实际是执行外面的代码
self.configureCellBlock(cell, item);
return cell;
}

@end
</code></pre>

<p>V层</p>

<pre><code> #import "TableViewController.h"
 #import "TableDataSource.h"
 static NSString * const kCellIdentifier = @"Cell";
 @interface TableViewController ()//定义一个实现UITableViewDataSource协议的类的属性。用于给tableview设置数据源
 @property (strong, nonatomic) TableDataSource *dataSource;
 @end

 @implementation TableViewController
 //自动生成get和set方法
 @synthesize dataSource = _dataSource;
- (void)viewDidLoad
{
[super viewDidLoad];
TableViewCellConfigureBlock cellConfigureBlock = ^(UITableViewCell *cell, NSString *item) {
    cell.textLabel.text = item;
};
NSArray *stringsArray = @[@"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3"];
self.dataSource = [[TableDataSource alloc] initWithItems:stringsArray
                                          CellIdentifier:kCellIdentifier
                                      ConfigureCellBlock:cellConfigureBlock];
self.tableView.dataSource = _dataSource;
 }

@end
</code></pre>

<p>   （3）下面的代码将用户登录的验证代码分离出来，但是应该不是完全的mvvm的模式，因为还是通过block进行的回调？还要多些代码体会理解
              类似VM层</p>

<pre><code>＃import &lt;Foundation/Foundation.h&gt;
//定义返回值参数的block的类型
typedef void (^RWSignInResponse)(BOOL);
@interface RWDummySignInService : NSObject
//在该方法的实现中，对传入的用户名密码进行处理，然后给block传入参数，并调用block
//定义一个包含输入参数及返回值block参数的函数。函数的返回值通过block传递出去，调用这个函数，执行block，就可以对这个返回值进行处理了。
- (void)signInWithUsername:(NSString *)username password:(NSString *)password complete:(RWSignInResponse)completeBlock;
@end


 ＃import "RWDummySignInService.h"
  @implementation RWDummySignInService
 //具体实现，传入用户名和密码，调用block（设置block的参数，然后回调传入的blobk的实现代码，
 //block作为方法的参数，调用方法的时候一定要实现这个block，方法的实现是调用这个block

 - (void)signInWithUsername:(NSString *)username password:(NSString *)password complete:(RWSignInResponse)completeBlock {
double delayInSeconds = 2.0;
//设置执行线程之前的等待时间,将前面的double类型进行一个转换
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
//执行线程，参数popTime：延迟时间。参数dispatch_get_main_queue()：获取运行在主线程的Main queue
dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
    BOOL success = [username isEqualToString:@"user"] &amp;&amp; [password isEqualToString:@"password"];
    completeBlock(success);
});
 }
@end
</code></pre>

<p>V层</p>

<pre><code> $import &lt;UIKit/UIKit.h&gt;
 @interface RWViewController : UIViewController
 @end


  #import "RWViewController.h"
  #import "RWDummySignInService.h"
  #import "ReactiveCocoa/ReactiveCocoa.h"
  @interface RWViewController ()
  @property (weak, nonatomic) IBOutlet UITextField *usernameTextField;
  @property (weak, nonatomic) IBOutlet UITextField *passwordTextField;
  @property (weak, nonatomic) IBOutlet UIButton *signInButton;
 @property (weak, nonatomic) IBOutlet UILabel *signInFailureText;
 @property (strong, nonatomic) RWDummySignInService *signInService; //处理用户点击事件的接口（信号）

 @end


 @implementation RWViewController

 - (void)viewDidLoad {
  [super viewDidLoad];
 //下面是创建（有效状态信号），理解其含义的代码
//我们可以使用map操作转换我们想要的数据，只需要它是一个对象，
RACSignal *validUsernameSignal = [self.usernameTextField.rac_textSignal map:^id(NSString *text) {
    return @(text.length &gt; 3);
  ]);
}];
RACSignal *validPasswordSignal = [self.passwordTextField.rac_textSignal map:^id(NSString *text) {
    return @(text.length &gt; 3);
}];
</code></pre>

<p> //下面ReactiveCocoa定义的一些宏，感觉这个宏是把函数要返回的对象的属性都声明了，直接return就行了</p>

<pre><code>RAC(self.passwordTextField, backgroundColor) = [validPasswordSignal map:^id(NSNumber *passwordValid){
    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}];

RAC(self.usernameTextField, backgroundColor) = [validUsernameSignal map:^id(NSNumber *usernameValid) {
    return [usernameValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}];
</code></pre>

<p>  //一开始将下面的combinelatest的参数直接用text，一致报找不到方法的错误，然后马上跟断点进行调试。发现应该要转换成信号。才可以</p>

<pre><code>RAC(self.signInButton, enabled) = [RACSignal combineLatest:@[self.usernameTextField.rac_textSignal, self.passwordTextField.rac_textSignal] reduce:^id(NSString *name, NSString *password){
    return @(name.length &gt; 3 &amp;&amp; password.length&gt;3);
}];
</code></pre>

<p>//正确的，将按钮点击事件映射到一个登录信号，但同时通过将事件从内部信号发送到外部信号，使这个过程变得扁平化。</p>

<pre><code>[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) {
    return [self signInSignal];
}] subscribeNext:^(NSNumber *signedIn) {
    BOOL success = [signedIn boolValue];
    self.signInFailureText.hidden = YES;
    if (success) {
        [self performSegueWithIdentifier:@"signInSuccess" sender:self];
    }
    NSLog(@"sign in result :%@",signedIn);

}];


 //创建处理点击事件的接口类对象
  self.signInService = [RWDummySignInService new];
 // 初始化提示框为隐藏
  self.signInFailureText.hidden = YES;
 }

- (RACSignal *)signInSignal{
return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [self.signInService signInWithUsername:self.usernameTextField.text password:self.passwordTextField.text complete:^(BOOL success) {
        [subscriber sendNext:@(success)];
        [subscriber sendCompleted];
    }];
    return nil;
}];
 }
 @end
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/09/11/ocnei-cun-guan-li/">OC内存管理</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-11T16:09:37+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:09 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、RunTime（运行时）概念理解</p>

<p>   （1）函数调用方式</p>

<pre><code>      OC的函数调用即通过在对象上调用方法，也称之为“传递消息”，相对于C语言函数调用，使用静态绑定，即在编译期就决定运行时所应调用的函数，OC则是通过动态绑定的方式，对所要调用的函数在运行期才能确定，即对象收到消息之后，究竟该调用哪个方法完全由运行期决定，并且可以在程序运行时改变，是一门真正的动态语言。
</code></pre>

<p>   （2）函数调用（传递消息）过程 1</p>

<pre><code>       函数调用过程即给对象发送消息的处理过程，以id returnValue = [someObject measageName:pameter] 消息为例：
       编译期，编译器看到这行代码，会将其转换为一条标准的C语言函数调用，id returnValue = objc_msgSend(someObject, @selector(messageName:),  parameter);  如果在编译期向类发送了其无法解读的消息也不会报错，因为运行时可以继续向类中添加方法。

       运行期，即动态消息派发系统执行过程，objc_msgSend函数会首先根据接收者（someObject）和选择子（measageName）的类型在接收者所属的类中搜寻它的方法列表，这个方法列表其实是类里面的一张表格，表格是一个存放健值对的列表，健用选择子的名字表示，值即选择子对应方法的函数指针，因为OC对象的每个方法都可以视为如下简单的C函数，&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)，这也是为什么后面找到相应匹配的方法后，能够跳转到相应实现代码的原因。
        如果在方法列表中找到与选择子名称相符的方法，就跳转到相应方法的实现代码，如果找不到，就沿着继承体系继续向上查找，若找到合适的方法就会再跳转到该方法实现代码，如果最终还是没找到相符合的代码，执行消息转发。即后面将要介绍的消息转发过程。《在这个过程中，objc_msgSend会将匹配结果缓存到快速映射表，这样后面执行相同的查找速度更快，尽管没有静态绑定的函数调用那么迅速，但是也不会慢很多了》
       下面的几个函数，与objc_msgSend函数类似，它们主要用于处理一些边界情况，可以了解一下
        objc_msgSend_stret 待发送的消息要返回结构体   objc_msgSend_fpret 待发送的消息要返回浮点数  objc_msgSendSuper待发送的消息要给超类发消息。
</code></pre>

<p>   （3）函数调用（消息转发）过程 2</p>

<pre><code>      经过上面传递消息过程还是没有找到匹配的方法之后，就会启动下面的消息转发过程。消息转发又分为动态方法解析、备援接受者、完整的消息转发三个步骤。
     动态方法解析：类的接受者，看是否能动态添加方法，以处理当前无法解读的选择子，首先要在所属类中重写下面的类方法，＋(BOOL) resolveInstanceMethod ( SEL )，前面是为了处理未知的实例方法，如果是处理未知的类方法，重写 ＋(BOOL) resolveClassMethod ( SEL )，selector 参数,即未知的选择子，在这里有机会新增处理此选择子的方法，若方法的实现代码已经写好，运行的时候就会动态插入到类里面。书本上coredata的dynamic属性即通过上面的方式实现。

     备援接受者：请接受者看看有没有其他对象能处理这条消息，这一步进行处理的相应方法为 － (id) forwardingTargetForSelector: (SEL) selector; 方法参数即代码未知选择子，注意：我们无法操作经由这一步转发的消息，要通过接受者自己去找备援对象，若找到则返回，找不到返回nil。 

    完整消息转发：修改消息的内容，即创建NSInvocation对象，把未能处理的消息的选择子，目标及参数封装到这个对象中，然后触发NSInvocation对象，把消息指派给目标对象，通过重写下列方法来转发消息。－ （void) forwardInvocation:(NSInvocation *) invocation。此方法默认实现，即改变调用目标，使消息在新目标上可以调用，这样与备援接受者实现的方法等效，只是在发送给备援接受者之前可以修改消息内容。
</code></pre>

<p>2、method swizzling的理解和用法</p>

<pre><code>    (1) Method Swizzling基本概念        
        通过前面对OC运行时的理解，允许我们修改selector(method name)到implementation(the method code itself)的映射。网上说，利用这个特性，我们可以"修补"那些没有源码的方法，如（AppKit，FoundationKit，或第三方的库等）。给这些方法基础上，增加新的操作，等和category不同的是，category如果定义了一个原来相同的方法，那么会直接覆盖原来的方法。Method Swizzling让你可以在替代原来的方法的同时可以调用原来的方法，并且为这个方法增加一些新的功能，记录日志等等，有点像subclassing。
    (2) Method Swizzling原理
    在前面已经讲到，在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。

  每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。
  selectorA --&gt; IMPa    selectorB --&gt; IMPb    selectorC --&gt;IMPc ....

 要实现互换两个函数的操作，首先要利用下面的两个函数：
 void method_exchangeImplementation(Method m1, Method m2)   //交换参数中传入的两个方法实现，方法实现可通过下面的函数获得
 Method class_geInstanceMethod (Class aClass, SEL aSelector)   //根据给定的选择从类中取出与之相关的方法的实现
以交换selectorA和selectorB两个方法的实现为例，交换后的指针指向为，selectorA --&gt; IMPb  selectorB --&gt;  IMPa

 (3) Method Swizzling实例代码
 以在NSString的一个分类中添加一个新的方法myLowercaseString ,与NSString已经存在的lowercaseString方法的交换为例，首先在分类中定义如下方法：

  @interface NSString (myAdditions)
 - (NSString *)myLowercaseString;
 @end

 @implementation NSString (myAdditions)
 - (NSString *)myLowercaseString {
NSString *lowercase = [self myLowercaseString];
NSLog(@"输出结果为:%@ =&gt; %@", self, lowercase);
return lowercase;
}
 @end

 // 通过下面代码来交换上面两个方法
Method originMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
 Method swappedMethod = class_getInstanceMethod([NSString class], @selector(myLowercaseString));
 method_exchangeImplementations(originMethod, swappedMethod);
 //最后在NSString上调用lowercaseString方法，会输出NSLog的打印语句，输出结果为:
 NSString *string = @"THIS IS THE STRING";
 NSString *lowercaseString = [string lowercaseString];

 //实际上，交换方法后，lowercaseString调用的是myLowercaseString的具体实现，而myLowercaseString里面又调用它自己指向的lowercaseString方法的实现，从而得到上面的输出结果
</code></pre>

<p>第三部分、懒加载</p>

<p>懒加载——也称为延迟加载，即在需要的时候才加载（效率低，占用内存小）。
注意：如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化</p>

<p>使用懒加载的好处：
（1）不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强
（2）每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合
具体实现：重写相关属性的get方法，在这个方法中alloc init该属性，如果是ui控件，在这里创建后添加到父控件上。</p>

<p>有一个问题：在ARC下使用懒加载，不在当前可见范围内的控件会不会做release处理，就像UITabBarController不在当前显示窗口上的viewcontroller就应该释放。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/15/iossheng-ming-zhou-qi-xiang-guan-zhi-shi-zong-jie/">iOS生命周期相关知识总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-15T13:18:11+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>1:18 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、 iOS工程中的各文件和目录的作用</p>

<pre><code>Tests文件用于单元测试（commad＋u 执行单侧命令)
Supporting files文件夹下Info.plist的文件，该文件对工程做一些运行期的配置，非常重要，不能删除
Localiztion native development region(CFBundleDevelopmentRegion)-本地化相关
Bundle display name(CFBundleDisplayName)-程序安装后显示  的名称,限制在10－12个字符，如果超出，将被显示缩写名称
Icon file(CFBundleIconFile)-app图标名称,一般为Icon.png
Bundle version(CFBundleVersion)-应用程序的版本号，每次往          
App Store上发布一个新版本时，需要增加这个版本号
Main storyboard file base name(NSMainStoryboardFile)-主storyboard文件的名称
Bundle identifier(CFBundleIdentifier)-项目的唯一标识，部署到真机时用到
.pch文件，是一个头文件(Xcode6没有找到)pch头文件的内容能被项目中的其他所有源文件共享和访问一般在pch文件中定义一些全局的宏
</code></pre>

<p>2、app的生命周期</p>

<p>  （1）执行main.m文件的main函数，实现下面两个操作</p>

<pre><code>  创建UIApplication对象
  创建UIApplication的delegate对象
  main函数中执行了一个UIApplicationMain这个函数：
 int UIApplicationMain(int argc, char *argv[], NSString *principalClassName, NSString *delegateClassName); 各个参数含义如下：
  argc、argv：直接传递给UIApplicationMain进行相关处理即可
  principalClassName：指定应用程序类名（app的象征），该类必须是UIApplication(或子类)。如果为nil,则用UIApplication类作为默认值
 delegateClassName：指定应用程序的代理类，该类必须遵守  UIApplicationDelegate协议，UIApplicationMain函数会根据principalClassName创建UIApplication对象，根据delegateClassName创建一个delegate对象，并将该delegate对象赋值给UIApplication对象中的delegate属性。

 以创建的sigle view applicaiton为例，相应方法实现为：return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
 （2）接着会建立应用程序的Main Runloop（事件循环）  
 如果有storyboard，根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard
 创建UIWindow
 创建和设置UIWindow的rootViewController（即storyboard属性面板的class属性定义的视图控制器）显示窗口
（再去执行delegate的相关方法）
如果没有storyboard，delegate对象开始处理(监听)系统事件程序启动完毕的时候, 就会调用代理的application:didFinishLaunchingWithOptions:方法在application:didFinishLaunchingWithOptions:中创建UIWindow创建和设置UIWindow的rootViewController显示窗口
</code></pre>

<p>   有一点不明白的地方就是，如果有storyboard的时候，是显示窗口之后，再去调用appdelegete代理的方法，还是先调用appdelegete代理的方法，再显示storyboard的窗口（解决办法，在代   理的application:didFinishLaunchingWithOptions:方法中创建uiwindow或对它重新赋值，看是否会覆盖storyboard）结论是先从storyboard加载，再执行代理方法。</p>

<p>   （3）UIWindow</p>

<p> UIWindow是一种特殊的UIView，通常在一个app中只会有一个UIWindow
iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的view，最后将控制器的view添加到UIWindow上，于是控制器的view就显示在屏幕上了</p>

<pre><code>一个iOS程序之所以能显示到屏幕上，完全是因为它有UIWindow,也就说，`没有UIWindow，就看不见任何UI界面
  /**
 *  程序启动完毕就会调用一次
 */
  - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
// 1.创建window
self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
// 2.设置window的背景色
self.window.backgroundColor = [UIColor whiteColor];    
MjOneViewController *one = [[MjOneViewController alloc] init];
// 方法一 :加入到UIWindow  [self.window addSubview:one.view];
//方法二 推荐
self.window.rootViewController = one;
// 3.显示window
[self.window makeKeyAndVisible];
return YES;
}

 最后，程序正常退出时UIApplicationMain函数才返回。
</code></pre>

<p>   3、对象的生命周期</p>

<pre><code>任何对象都是继承自NSObject的，可以通过重写下列方法，设置对象的初始化。
+ (void)load;
+ (void)initialize;
- (instancetype)init
</code></pre>

<p>   4、视图控制器的生命周期</p>

<pre><code> loadView     从nib载入视图 ，通常这一步不需要去干涉。
 loadView 此方法在控制器的view为nil的时候被调用。 此方法用于以编程的方式创建view的时候用到。 如：
- ( void ) loadView {
UIView *view = [ [ UIView alloc] initWithFrame:[ UIScreen mainScreen] .applicationFrame] ;
[ view setBackgroundColor:_color] ;
self.view = view;  }

 viewDidLoad方法：此方法为控制器已被实例化，在视图被加载到内存中的时候调用该方法，这个时候视图并未出现。在该方法中通常进行的是对所控制的视图进行初始化处理。
  viewDidLoad方法在应用运行的时候只调用一次，而其他4个方法viewWillAppear   viewDidAppear   viewWillDisapper    viewDidDisapper可以被反复调用多次，它们的使用很广泛但同时也具有很强的技巧性。
 iOS系统在低内存时情况下会调用didReceiveMemoryWarning:该方法的主要职能是释放内存，包括视图控制器中的一些成员变量和视图的释放

  ViewController的生命周期中各方法执行流程如下：
  init—&gt;loadView—&gt;viewDidLoad—&gt;viewWillApper—&gt;viewDidApper—&gt;viewWillDisapper—&gt;viewDidDisapper—&gt;viewWillUnload-&gt;viewDidUnload—&gt;dealloc

 修改应用初始启动时关联的storyboard文件，通过代码创建初始启动的视图控制器
 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
// Override point for customization after application launch.
//重新设置self.window
self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] applicationFrame]];
ViewController *vc = [[ViewController alloc] init];
UINavigationController *nvc = [[UINavigationController alloc] initWithRootViewController:vc];
self.window.backgroundColor = [UIColor whiteColor];
//设置window上加载的视图控制器
self.window.rootViewController = nvc;
//使改动生效
[self.window makeKeyAndVisible];
NSLog(@"%s",__FUNCTION__);
return YES;
}
</code></pre>

<p>   通过创建storyboard加载视图控制器的方法：
创建一个storyboard，New File &ndash;> IOS &ndash;> User Interface &ndash;> Storyboard
设置storyboard右侧的class属性为相应视图控制器类
在代码中创建storyboard的同时，启动相应的视图控制器
UIStoryboard *two = [UIStoryboard storyboardWithName:@&ldquo;Main&rdquo; bundle:nil];
[self.navigationController pushViewController:[two instantiateInitialViewController] animated:YES];
创建视图控制器时勾选创建xib，自动生成对应xib文件
New File &ndash;> IOS &ndash;> Source &ndash;> Cocoa Touch Class(勾选Also create Xib File)</p>

<p>   通过手动创建带xib的视图控制器
创建一个xib文件，New File &ndash;> IOS &ndash;> User Interface &ndash;> view
FiveViewController *fiveVC = [[FiveViewController alloc]initWithNibName:@&ldquo;other&rdquo; bundle:nil];
    [self.navigationController pushViewController:fiveVC animated:YES];</p>

<p>5、 视图控制器装载和卸载视图的过程</p>

<p>   ViewController的职责主要包括管理内部各个view的加载显示和卸载，同时负责与其他ViewController的通信和协调
        ViewController可以分为两类：
        一类是显示内容的，比如UIViewController、UITableViewController等，同时还可以自定义继承自UIViewController的ViewController；另一类是ViewController容器，UINavigationViewController和UITabBarController等
         在控制器view加载过程中首先会调用loadView方法，在这个方法中主要完成一些关键view的初始化工作，比如UINavigationViewController和UITabBarController等容器类的ViewController；接下来就是加载view，加载成功后，会接着调用viewDidLoad方法，这里要记住的一点是，在loadView之前，是没有view的，也就是说，在这之前，view还没有被初始化。完成viewDidLoad方法后，ViewController里面就成功的加载view了，如下图右下角所示。
在Controller中创建view有两种方式，一种是通过代码创建、一种是通过Storyboard或Interface Builder来创建，后者可以比较直观的配置view的外观和属性
 关于loadView方法的重写，官方文档中有一个明显的注释，当通过代码方式去创建你自己的view时，在loadView方法中不应该调用super，如果调用[super loadView]会影响CPU性能。
  - (void)loadView<br/>
{<br/>
     CGRect applicationFrame = [[UIScreen mainScreen] applicationFrame];<br/>
     UIView *contentView = [[UIView alloc] initWithFrame:applicationFrame];<br/>
     contentView.backgroundColor = [UIColor blackColor];<br/>
     self.view = contentView; <br/>
}
view加载过程.png
       当系统发出内存警告时，会调用didReceiveMemoeryWarning方法，如果当前有能被释放的view，系统会调用viewWillUnload方法来释放view，完成后调用viewDidUnload方法，至此，view就被卸载了。此时原本指向view的变量要被置为nil，具体操作是在viewDidUnload方法中调用self.myButton = nil。
ViewController中view卸载过程.png
        loadView和viewDidLoad的区别就是，loadView时view还没有生成，viewDidLoad时，view已经生成了，loadView只会被调用一次，而viewDidLoad可能会被调用多次（View可能会被多次加载），当view被添加到其他view中之前，会调用viewWillAppear，之后会调用viewDidAppear。当view从其他view中移除之前，调用viewWillDisAppear，移除之后会调用viewDidDisappear。当view不再使用时，受到内存警告时，ViewController会将view释放并将其指向为nil。</p>

<p>6、视图UIView的生命周期</p>

<p>  常用方法如下：
- (void)removeFromSuperview;
- (void)insertSubview:(UIView *)view atIndex:(NSInteger)index;
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;</p>

<ul>
<li>(void)addSubview:(UIView *)view;</li>
<li>(void)insertSubview:(UIView <em>)view belowSubview:(UIView </em>)siblingSubview;</li>
<li><p>(void)insertSubview:(UIView <em>)view aboveSubview:(UIView </em>)siblingSubview;</p></li>
<li><p>(void)bringSubviewToFront:(UIView *)view;</p></li>
<li><p>(void)sendSubviewToBack:(UIView *)view;</p></li>
<li><p>(void)didAddSubview:(UIView *)subview;</p></li>
<li><p>(void)willRemoveSubview:(UIView *)subview;</p></li>
<li><p>(void)willMoveToSuperview:(nullable UIView *)newSuperview;</p></li>
<li>(void)didMoveToSuperview;</li>
<li>(void)willMoveToWindow:(nullable UIWindow *)newWindow;</li>
<li>(void)didMoveToWindow;</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/29/ocyun-xing-shi-ji-xiao-xi-zhuan-fa/">OC运行时及消息转发</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-29T14:20:52+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:20 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、RunTime（运行时）概念理解</p>

<p>   （1）函数调用方式</p>

<pre><code>   OC的函数调用即通过在对象上调用方法，也称之为“传递消息”，相对于C语言函数调用，使用静态绑定，即在编译期就决定运行时所应调用的函数，OC则是通过动态绑定的方式，对所要调用的函数在运行期才能确定，即对象收到消息之后，究竟该调用哪个方法完全由运行期决定，并且可以在程序运行时改变，是一门真正的动态语言。
</code></pre>

<p>   （2）函数调用（传递消息）过程 1</p>

<pre><code>  函数调用过程即给对象发送消息的处理过程，以id returnValue = [someObject measageName:pameter] 消息为例：

  编译期，编译器看到这行代码，会将其转换为一条标准的C语言函数调用，id returnValue = objc_msgSend(someObject, @selector(messageName:),  parameter); 如果在编译期向类发送了其无法解读的消息也不会报错，因为运行时可以继续向类中添加方法。

 运行期，即动态消息派发系统执行过程，objc_msgSend函数会首先根据接收者（someObject）和选择子（measageName）的类型在接收者所属的类中搜寻它的方法列表，这个方法列表其实是类里面的一张表格，表格是一个存放健值对的列表，健用选择子的名字表示，值即选择子对应方法的函数指针，因为OC对象的每个方法都可以视为如下简单的C函数，&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)，这也是为什么后面找到相应匹配的方法后，能够跳转到相应实现代码的原因。

  如果在方法列表中找到与选择子名称相符的方法，就跳转到相应方法的实现代码，如果找不到，就沿着继承体系继续向上查找，若找到合适的方法就会再跳转到该方法实现代码，如果最终还是没找到相符合的代码，执行消息转发。即后面将要介绍的消息转发过程。《在这个过程中，objc_msgSend会将匹配结果缓存到快速映射表，这样后面执行相同的查找速度更快，尽管没有静态绑定的函数调用那么迅速，但是也不会慢很多了》
       下面的几个函数，与objc_msgSend函数类似，它们主要用于处理一些边界情况，可以了解一下
        objc_msgSend_stret 待发送的消息要返回结构体   objc_msgSend_fpret 待发送的消息要返回浮点数  objc_msgSendSuper待发送的消息要给超类发消息。
</code></pre>

<p>  （3）函数调用（消息转发）过程 2</p>

<pre><code>   经过上面传递消息过程还是没有找到匹配的方法之后，就会启动下面的消息转发过程。消息转发又分为动态方法解析、备援接受者、完整的消息转发三个步骤。

   动态方法解析：类的接受者，看是否能动态添加方法，以处理当前无法解读的选择子，首先要在所属类中重写下面的类方法，＋(BOOL) resolveInstanceMethod ( SEL )，前面是为了处理未知的实例方法，如果是处理未知的类方法，重写 ＋(BOOL) resolveClassMethod ( SEL )，selector 参数,即未知的选择子，在这里有机会新增处理此选择子的方法，若方法的实现代码已经写好，运行的时候就会动态插入到类里面。书本上coredata的dynamic属性即通过上面的方式实现。

    备援接受者：请接受者看看有没有其他对象能处理这条消息，这一步进行处理的相应方法为 － (id) forwardingTargetForSelector: (SEL) selector; 方法参数即代码未知选择子，注意：我们无法操作经由这一步转发的消息，要通过接受者自己去找备援对象，若找到则返回，找不到返回nil。 

    完整消息转发：修改消息的内容，即创建NSInvocation对象，把未能处理的消息的选择子，目标及参数封装到这个对象中，然后触发NSInvocation对象，把消息指派给目标对象，通过重写下列方法来转发消息。－ （void) forwardInvocation:(NSInvocation *) invocation。此方法默认实现，即改变调用目标，使消息在新目标上可以调用，这样与备援接受者实现的方法等效，只是在发送给备援接受者之前可以修改消息内容。
</code></pre>

<p>2、method swizzling的理解和用法</p>

<p>   (1) Method Swizzling基本概念</p>

<pre><code>    通过前面对OC运行时的理解，允许我们修改selector(method name)到implementation(the method code itself)的映射。网上说，利用这个特性，我们可以"修补"那些没有源码的方法，如（AppKit，FoundationKit，或第三方的库等）。给这些方法基础上，增加新的操作，等和category不同的是，category如果定义了一个原来相同的方法，那么会直接覆盖原来的方法。Method Swizzling让你可以在替代原来的方法的同时可以调用原来的方法，并且为这个方法增加一些新的功能，记录日志等等，有点像subclassing。
</code></pre>

<p>   (2) Method Swizzling原理</p>

<pre><code>   在前面已经讲到，在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。
  每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。
  selectorA --&gt; IMPa    selectorB --&gt; IMPb    selectorC --&gt;IMPc ....
 要实现互换两个函数的操作，首先要利用下面的两个函数：
 void method_exchangeImplementation(Method m1, Method m2)   //交换参数中传入的两个方法实现，方法实现可通过下面的函数获得
 Method class_geInstanceMethod (Class aClass, SEL aSelector)   //根据给定的选择从类中取出与之相关的方法的实现
以交换selectorA和selectorB两个方法的实现为例，交换后的指针指向为，selectorA --&gt; IMPb  selectorB --&gt;  IMPa
 (3) Method Swizzling实例代码
 以在NSString的一个分类中添加一个新的方法myLowercaseString ,与NSString已经存在的lowercaseString方法的交换为例，首先在分类中定义如下方法：
</code></pre>

<p>@interface NSString (myAdditions)
     - (NSString *)myLowercaseString;
@end</p>

<p>@implementation NSString (myAdditions)
- (NSString <em>)myLowercaseString {
    NSString </em>lowercase = [self myLowercaseString];
    NSLog(@&ldquo;输出结果为:%@ => %@&rdquo;, self, lowercase);
    return lowercase;
}
@end
// 通过下面代码来交换上面两个方法
Method originMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
Method swappedMethod = class_getInstanceMethod([NSString class], @selector(myLowercaseString));
method_exchangeImplementations(originMethod, swappedMethod);</p>

<p>//最后在NSString上调用lowercaseString方法，会输出NSLog的打印语句，输出结果为:
NSString <em>string = @&ldquo;THIS IS THE STRING&rdquo;;
NSString </em>lowercaseString = [string lowercaseString];
//实际上，交换方法后，lowercaseString调用的是myLowercaseString的具体实现，而myLowercaseString里面又调用它自己指向的lowercaseString方法的实现，从而得到上面的输出结果</p>

<p>第三部分、懒加载</p>

<p>懒加载——也称为延迟加载，即在需要的时候才加载（效率低，占用内存小）。
注意：如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化</p>

<p>使用懒加载的好处：</p>

<p>（1）不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强</p>

<p>（2）每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合
具体实现：重写相关属性的get方法，在这个方法中alloc init该属性，如果是ui控件，在这里创建后添加到父控件上。</p>

<p>有一个问题：在ARC下使用懒加载，不在当前可见范围内的控件会不会做release处理，就像UITabBarController不在当前显示窗口上的viewcontroller就应该释放。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/15/git-xue-xi-bi-ji/">Git 学习笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-15T11:09:27+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:09 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、理解git在本地常用的操作
  （1）git status命令的作用，即从查看本地仓库中出现了的修改和变化的角度去想，如添加、修改和删除文件的操作。比较常见的就是添加新的文件和修改仓库中的某个文件。该命令方便我们查看我们在本地所做的一些修改。 <br/>
   2）git本地操作的三个区域<br/>
         工作区  暂存区  版本库</p>

<p>   1、下面以新增加的文件为例，通过git status查看，它是Untracked files（未跟踪的文件）－》工作区。运行git add－》暂存区。再运行git commit－》本地版本库。
   如果在暂存区的时候对这个文件进行了修改，通过git status查看，该文件一个还在暂存区Changes to be committed，一个在工作区Changes not staged for commit。</p>

<p>   2、下面对修改本地仓库中的某个文件为例。通过status查看，它是Changes not staged for commit:－》工作区。运行git add－》暂存区，再运行git commit－》本地版本库。如果在暂存区对这个文件进行修改，结果与前面也是一样的。（即出现两个一样的文件）</p>

<p>   3、下面对删除本地仓库中的某个文件为例，如果是手工删除或者使用［rm 文件名］删除，通过status查看，Changes not staged for commit－》工作区。运行git rm 文件名－－》暂存区。再运行git commit－》本地版本库，该文件就不再纳入版本管理 git rm &ndash;cached readme.txt  要移除跟踪但不删除文件，即从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件比较适应  git mv file_from file_to  对文件改名</p>

<p>   最后总结，在工作区，文件有可能是新增加未跟踪的，有可能是修改未暂存，有可能是暂存后又修改未暂存的，有可能是跟踪后暂存然后修改未暂存的。开始总是会把未跟踪、未暂存、未提交这几种状态弄晕，其实只是表示一个状态，要与他实际的工作区域对应上，即从前面两个角度去分析。</p>

<p>2、远程仓库使用（注意与本地仓库进行区分）
   方式一：git clone git地址  克隆一个远程仓库到本地，会在本地当前目录下创建一个和远程仓库一样的文件夹，testlf。进入这个文件夹，就可以看到➜  testlf git:(master) . 用git管理项目的标识
   方式二：git init   对当前文件夹下的文件用git进行管理。会在当前文件夹下生成一个.git的隐藏文件。但是没有与任何远程仓库关联。那如何与远程仓库进行关联呢？
    1、git remote add pb git://github.com/paulboone/ticgit.git   //本操作含义：添加一个新的远程仓库，可以指定一个简单的名字,还没有进行任何关联，一般默认的仓库名是origin
     2、git fetch pb  / /抓取所有 Paul 上的数据。完成这个操作，Paul 的主干分支（master）已经完全可以在本地访问了，对应的名字是 pb/master
     3、你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新 （本地仓库和远程仓库的内容就相当于两个分支了，还要自己去尝试做）
    总结：不过我觉得一般开始管理远程仓库，都会先在远程上创建一个仓库create repository。然后将他clone到本地。在这个仓库对应的本地文件夹下创建项目，或者将要用git管理的工程复制到这个项目下，就可以对它add。。。等的操作进行管理和push到远程仓库了。并且本地所做的任何更改，都可以提交到远程仓库。</p>

<p>3、本地分支的新建与合并
     （1）基本命令
      git branch 分支名   //新建一个分支
      git checkout 分支名   //切换到相应分支
      注意：切换分支的时候最好保持一个清洁的工作区域。切换到下一个分支之前，保证工作区、暂存区的内容都已经提交。不然会混淆。并且它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支
      git branch   //不加任何参数，可以查看当前分支清单，分支前的＊号表示当前所在分支
      git branch -v //查看各个分支最后一个提交对象的信息
      git branch &ndash;merged  //查看已经合并的分支
      git branch – no-merged  //查看没有合并的分支
      git branch -d 分支名 //可以删除已经合并了的，如果删除没有合并的，会提示错误
      git branch -D 分支名  //强制删除没有合并的分支
     （2）分支指针
       master分支指针
       创建新的分支，就相当于创建了一个新的分支指针。
       head指针：切换分支时，指向你当前工作的分支
      画分支关系图的时候，主干分支横着画，创建的新分支竖着画，这样理解更清晰一些，如果一个分支下还有多个分支时，也可以竖着并行排列即可。
       （3）分支合并
       比较容易出现的一种情况即，在某个分支下新建一个分支后，做了很多次提交。而（从原来分支远程pull数据下来的时候，或者本地去做了一些修改的时候）原来的分支页进行了提交，并且可能与其他分支进行了merge操作，如下所示：</p>

<p>这里执行：
git merge iss53</p>

<p>  Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。
合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）。如下所示：</p>

<p>Git 作了合并，但没有提交，如果有冲突会提示。
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
并且停下来等你解决冲突，可以用 git status 查阅：并且会显示未解决冲突的具体文件。直接打开相应文件，用vim进行手动修改即可</p>

<p>可以看到 很多等号 隔开的到 很多尖括号 HEAD的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容。下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。
最后 尖括号和等号 这些行是需要手动删除的。下面是选其一的方式解决冲突</p>

<p>运行 git add 将把它们标记为已解决状态 ，再运行一次 git status 来确认所有冲突都已解决，就可以提交了。</p>

<p>  （4）长期分支理解</p>

<p>   master 分支中保留完全稳定的代码，即已经发布或即将发布的代码。 develop 或 next 的平行分支，专门用于后续的开发。一旦进入某种稳定状态，便可以把它合并到 master 里。
     下面是书本上的一个例子，起先我们在 master 工作到 C1，然后开始一个新分支 iss91 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支 iss91v2，干到 C8 的时候，又回到主干 master 中提交了 C9 和 C10，再回到iss91v2 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 master 的最新提交 C10 处开了个新的分支 dumbidea 做些试验。</p>

<p>   对于从之前 C4 的地方又分出一个分支 iss91v2，我一直都不太明白，是怎么回到分支的某个commit的。原来git还有一个很高级的命令
<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000</a></p>

<p> （5）版本回退命令
   git reset &ndash;hard HEAD^
 因为Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交（通过git log／git log &ndash;pretty=oneline），
可以查看提交的commit号。上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。
回退到相应版本之后，查看相应文件，就会发现也会回到之前修改的状态。通过git log查看版本库也会发现。回退版本之前的版本都没有了。
      1、如果想回到之前最新的版本，怎么办，
只要命令行终端没有关闭，找到之前git log查看的相应版本的commitid，然后使用下面的命令即可
git reset &ndash;hard 命令号（取前几位就可以了），然后再查看相应文件，发现又回到最新的了。
2、如果关闭电脑，关闭命令行终端后，想回到之前最新的版本，怎么办
使用git reflog  就可以查看每一次命令的记录，然后就可以找到相应版本的commitid号</p>

<p>   总结
   HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset &ndash;hard commit_id。
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>

<p>5、远程分支的理解和使用
远程分支的表示形式： (远程仓库名)/(分支名)
通过下面的图对远程分支和本地分支进行一个对比，同时与远程仓库和本地仓库的概念区分开。</p>

<p>5、创建远程分支方法
      （1）我是在本地执行如下命令时，git push origin master:new-remote-branch，如果远程没有一个名为new-remote-branch的分支，系统就会自动创建一个origin/new-remote-branch的远程分支了。
git push (远程仓库名)  (本地分支名) : (远程分支名)
 （可以将本地的某个分支提交到远程的任意一个分支，这个分支就默认跟踪了这个远程分支），
➜  gcdTestForGit git:(master) git push origin master:new-remote-branch
Counting objects: 4, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 353 bytes | 0 bytes/s, done.
Total 4 (delta 2), reused 0 (delta 0)
remote:
remote: Create pull request for new-remote-branch:
remote:   git分支
remote:
To git地址
 * [new branch]      master -> new-remote-branch
➜  gcdTestForGit git:(master)
   （2）跟踪某个远程分支 方法：  从远程分支 checkout 出对应的本地分支，即相当于在本地创建一个与远程一样的分支，进行跟踪
      创建方式：
      git checkout -b master origin/master   ／／从远程分支新建并切换到master 本地分支，其内容同远程分支 origin/master 一致，这样你就可以在里面继续开发了   。其实这些在git clone  的时候git都给我们做好了。但是如果是其他git add 的远程分支，我们就需要手动去做这些操作。
➜  gcdTestForGit git:(master) git checkout -b test-link-remote origin/new-remote-branch<br/>
Branch test-link-remote set up to track remote branch new-remote-branch from origin.
Switched to a new branch &lsquo;test-link-remote&rsquo;
➜  gcdTestForGit git:(test-link-remote)
      git checkout &ndash;track origin/master    ／／1.6.2 以上版本的 Git，对上面第一种创建方式进行简化。要为本地分支设定不同于远程分支的名字，就使用第一种方式换个名字即可。
      作用：1、跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。
           2、同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。
      注意：如果要在特定的远程分支中工作，提交数据，必须先按照上面的方式在本地先跟踪这个分支（比如development分支），然后在这个本地分支下再新建分支（如bugfix/mybranch，进行操作，完成后提交到远程的bugfix/mybranch分支，最后在远程合并到development分支
     实例操作：
      我们可以通过创建很多个本地分支来追踪某个远程分支。然后每次push，都自动提交到这个远程分支下。最后master分支可以将远程分支合并。
如下图所示。
test2-link-remote和test-link-remote是跟踪远程分支origin／new-remote-branch 的两个本地分支。当本地分支test2-link-remote   push到跟踪的远程分支上时，会提示本地分支test-link-remote落后远程分支一个版本，</p>

<p>这时可以切换到test-link-remote分支下，执行pull操作，就可以保持他们一致，如下图所示：</p>

<p>合并两个远程分支
如上面例子所示：合并origin/master   与  origin/new-remote-branch .解决相应冲突即可(解决冲突的方法见上面）
➜  gcdTestForGit git:(master) git merge origin/new-remote-branch
Auto-merging gcdTestForGit/test1.txt
CONFLICT (content): Merge conflict in gcdTestForGit/test1.txt
Auto-merging gcdTestForGit/test.txt
CONFLICT (content): Merge conflict in gcdTestForGit/test.txt
Automatic merge failed; fix conflicts and then commit the result.
➜  gcdTestForGit git:(master) ✗
具体解决冲突如下：
➜  gcdTestForGit git:(master) ✗ git status
On branch master
Your branch is up-to-date with &lsquo;origin/master&rsquo;.
You have unmerged paths.
  (fix conflicts and run &ldquo;git commit&rdquo;)</p>

<p>Unmerged paths:
  (use &ldquo;git add <file>&hellip;&rdquo; to mark resolution)</p>

<p> both modified:   test.txt
 both modified:   test1.txt</p>

<p>no changes added to commit (use &ldquo;git add&rdquo; and/or &ldquo;git commit -a&rdquo;)
➜  gcdTestForGit git:(master) ✗ vim test.txt
➜  gcdTestForGit git:(master) ✗ vim test1.txt
➜  gcdTestForGit git:(master) ✗ git status
On branch master
Your branch is up-to-date with &lsquo;origin/master&rsquo;.
You have unmerged paths.
  (fix conflicts and run &ldquo;git commit&rdquo;)</p>

<p>Unmerged paths:
  (use &ldquo;git add <file>&hellip;&rdquo; to mark resolution)</p>

<p> both modified:   test.txt
 both modified:   test1.txt</p>

<p>no changes added to commit (use &ldquo;git add&rdquo; and/or &ldquo;git commit -a&rdquo;)
➜  gcdTestForGit git:(master) ✗ git add .
➜  gcdTestForGit git:(master) ✗ git status
On branch master
Your branch is up-to-date with &lsquo;origin/master&rsquo;.
All conflicts fixed but you are still merging.
  (use &ldquo;git commit&rdquo; to conclude merge)</p>

<p>Changes to be committed:</p>

<p> modified:   test.txt
 modified:   test1.txt</p>

<p>➜  gcdTestForGit git:(master) ✗ git commit -m &lsquo;submit-git-test-10&rsquo;
[master 95552e2] submit-git-test-10
➜  gcdTestForGit git:(master) gi status
zsh: command not found: gi
➜  gcdTestForGit git:(master) git status
On branch master
Your branch is ahead of &lsquo;origin/master&rsquo; by 3 commits.
  (use &ldquo;git push&rdquo; to publish your local commits)
nothing to commit, working directory clean
➜  gcdTestForGit git:(master) git push origin master
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 545 bytes | 0 bytes/s, done.
Total 5 (delta 2), reused 0 (delta 0)
To git分支  master -> master
➜  gcdTestForGit git:(master)
远程分支合并后的结果如下：</p>

<p>删除远程分支
git push [远程名] :[分支名]    ／／其实它是省略了《git push [远程名] [本地分支]:[远程分支]》命令中的本地分支。即提取一个空白的本地分支到远程分支。所有一定要注意这个两个命令的区别。使用git push命令做提交操作时一定要注意，如果写了（：），一定要加本地分支名</p>

<p>问题：如果某个本地分支没有与远程分支关联，（在master分支下，好像默认跟踪的master，还是），可以push到别的远程仓库吗？
如下：在master下创建一个分支，在本地做修改并且做了commit提交，但是没有push。
然后把它push到别的远程分支会是什么情况？
➜  gcdTestForGit git:(test-local-branch) git push origin test-local-branch:new-remote-branch
Counting objects: 4, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 363 bytes | 0 bytes/s, done.
Total 4 (delta 3), reused 0 (delta 0)
remote:
remote: Create pull request for new-remote-branch:
remote:   git分支
remote:
To git地址
   103f55f..852a6ea  test-local-branch -> new-remote-branch
➜  gcdTestForGit git:(test-local-branch)
结果：test-local-branch分支变成了跟踪new-remote-branch远程分支的一个本地分支
并且切换到远程分支new-remote-branch中，可以看到在本地test-local-branch分支中做的修改，说明push成功了。
结论：在本地创建一个分支的时候，（跟踪某个远程分支的作用是可以fetch／pull这个远程分支的数据，不跟踪貌似也能拉取它的数据，所以我觉得本地分支和远程分支在push之前好像没有很大联系），在push操作之前，一定要对远程分支进行fetch／pull的操作拉取新的更新数据，然后push。
好像push fetch pull的时候都不会出现冲突（push就是把本地的覆盖远程的，fetch／pull远程覆盖本地的），只有merge的时候才会有冲突。</p>

<p>所以在做项目时应该是每个人创建属于自己的远程分支（所以push都只覆盖自己），然后某个人去把这个远程分支进行merge时再去解决冲突。最后可能就把merge后的分支再与主远程分支merge
下面这篇博客讲了多人协作开发中git在不同场景下的使用，可以多看看，多试着练习一下，博客最后有人提了一个问题，其实也是我不太懂的。就是怎么建远程分支，好像我前面都是建本地分支时设置一个远程分支，然后就自动生成， 问了一下我们项目时开一个task的时候，可以在那个网页上建远程分支就可以了。
<a href="http://limboy.me/tech/2011/02/25/git-workflow-with-blog-demo.html">http://limboy.me/tech/2011/02/25/git-workflow-with-blog-demo.html</a></p>

<p>下面是我做的一次练习测试，加深我对git多人协作开发流程的理解</p>

<p>在当前分支下，提交多次。并且push到对应的远程分支</p>

<p>git:(new-remote-branch) git push origin new-remote-branch。结果如下所示</p>

<p>然后利用版本回退，回到前面的第二个commit
git:(new-remote-branch) git reset &ndash;hard HEAD~2</p>

<p>此时还会提示你要git pull远程上的commit，但是你想把前面的两个commit都删除。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git status
On branch new-remote-branch
Your branch is behind &lsquo;origin/new-remote-branch&rsquo; by 2 commits, and can be fast-forwarded.
  (use &ldquo;git pull&rdquo; to update your local branch)
nothing to commit, working directory clean</p>

<p>这时又在这里做了多次commit。即出现分支的分化（分叉），直接push的话，git会默认对这些分支进行一个merge。如果有冲突就会出现错误，不知道是不是的。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) vim test1.txt
➜  gcdTestForGit git:(new-remote-branch) ✗ git add .
➜  gcdTestForGit git:(new-remote-branch) ✗ git commit -m &lsquo;submit-08-14-06&rsquo;
[new-remote-branch cfb560b] submit-08-14-06
 1 file changed, 1 insertion(+), 1 deletion(-)</p>

<p>如下图所示</p>

<p>再做一次和前面一样的commit操作，得到如下</p>

<p>其实上面的图显示的告诉你，可以git merge来合并。但是如果我直接push的话，看一下会出现什么结果.果然出错了。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git push origin new-remote-branch
To git地址
 ! [rejected]        new-remote-branch -> new-remote-branch (non-fast-forward)
error: failed to push some refs to &lsquo;git地址&rsquo;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: &lsquo;git pull &hellip;&rsquo;) before pushing again.
hint: See the &lsquo;Note about fast-forwards&rsquo; in &lsquo;git push &ndash;help&rsquo; for details.</p>

<p>然后运行git status，提示你要先pull</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git status
On branch new-remote-branch
Your branch and &lsquo;origin/new-remote-branch&rsquo; have diverged,
and have 2 and 2 different commits each, respectively.
  (use &ldquo;git pull&rdquo; to merge the remote branch into yours)
nothing to commit, working directory clean
git pull之后就会告诉你有哪些冲突，然后解决冲突后就可以了。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git pull
Auto-merging gcdTestForGit/test1.txt
CONFLICT (content): Merge conflict in gcdTestForGit/test1.txt
Automatic merge failed; fix conflicts and then commit the result.</p>

<p>最后解决冲突，然后commit push之后，就可以了</p>

<p>➜  gcdTestForGit git:(new-remote-branch) ✗ vim test1.txt
➜  gcdTestForGit git:(new-remote-branch) ✗ git add .
➜  gcdTestForGit git:(new-remote-branch) ✗ git commit -m &lsquo;submit-08-14-08&rsquo;
[new-remote-branch 3dd204d] submit-08-14-08
➜  gcdTestForGit git:(new-remote-branch) git push origin new-remote-branch
Counting objects: 12, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (12/12), 1.00 KiB | 0 bytes/s, done.
Total 12 (delta 9), reused 0 (delta 0)
remote:
remote: Create pull request for new-remote-branch:
remote:   git分支
remote:
To git地址
   c66c1bc..3dd204d  new-remote-branch -> new-remote-branch</p>

<p>但是如果想强制将分叉本地分支覆盖掉远程分支上。而submit－08-14-04和submit－08-14－05两次commit的操作都删除的话，使用git push origin new-remote-branch。即加一个－f的参数。就可以不记性pull然后解决冲突了。</p>

<p>总结：通过上面的实验，让我明白了在一个分支上一直commit push的话，直接覆盖前面的。只有当在这个分支上（如回退到某个分岔点）出现分岔的时候才需要merge等的操作，就可能需要解决冲突。所以很多人在一个远程分支上工作的时候。一般如果有人push了，则你在本地想要push
的时候，先运行git status，一般就会告诉你先git pull，然后如果没有冲突你再push就可以了。如果是你一个人在远程分支上工作貌似就没关系。</p>

<p>git rebase的理解：修改当前分支的基底分支，在基底分支上重演一遍分支中所做的修改，这个命令执行后不会出现马上要解决冲突，因为它还是生成了一个分支，只有从新的基底分支merge这个分支的时候才可能出现要解决冲突。</p>

<p>［第一部分］
<a href="http://blog.csdn.net/u010520912/article/details/18993001">http://blog.csdn.net/u010520912/article/details/18993001</a>
创建github账号及上传代码的步骤
github账号地址
<a href="https://github.com/amyliangfang/lf/blob/master/c-01/c-01">https://github.com/amyliangfang/lf/blob/master/c-01/c-01</a>
具体步骤：
注册github账号－使用ssh密钥认证－创建本地仓库并上传代码到github</p>

<p>参考书籍：
<a href="http://git-scm.com/book/en/v2">http://git-scm.com/book/en/v2</a></p>

<p><a href="http://pcottle.github.io/learnGitBranching/">http://pcottle.github.io/learnGitBranching/</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/11/27/cocoapodsshi-jian/">CocoaPods实践</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/01/swift-xue-xi-zong-jie/">Swift 学习总结</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/20/mvvmkuang-jia-xue-xi-shi-jian/">MVVM框架学习实践</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/11/ocnei-cun-guan-li/">OC内存管理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/15/iossheng-ming-zhou-qi-xiang-guan-zhi-shi-zong-jie/">iOS生命周期相关知识总结</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
