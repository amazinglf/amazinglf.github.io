
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>我的iOS开发之旅</title>
  <meta name="author" content="梁芳">

  
  <meta name="description" content="1、RunLoop与线程关系 原理：从上面的表格可以看出，线程和RunLoop是息息相关的，即线程和RunLoop是一一对应的关系，从获取RunLoop的 源码(https://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c.auto. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://amazinglf.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="我的iOS开发之旅" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">我的iOS开发之旅</a></h1>
  
    <h2>你若安好，便是晴天☀️</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="amazinglf.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/runloopxue-xi-diao-yan/">Runloop学习调研</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-12-11T16:32:17+08:00'><span class='date'>2016 年12 月11 日</span> <span class='time'>4:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>1、RunLoop与线程关系</h3>

<p><img src="../images/runloop3.png" alt="Alt text" /></p>

<p> 原理：从上面的表格可以看出，线程和RunLoop是息息相关的，即线程和RunLoop是一一对应的关系，从获取RunLoop的   源码(<a href="https://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c.auto.html">https://opensource.apple.com/source/CF/CF-1151.16/CFRunLoop.c.auto.html</a>)可以看出，它是通过一个字典来实现线程和RunLoop之前一一对应关系的</p>

<p><img src="../images/runloop1.png" alt="Alt text" /> <br/>
 注意：CoreFoundation中方法是线程不安全的，而OC中方法是线程安全的，且OC方法是对CoreFoundation中方法的封装。使用CoreFoundation方法在保证线程安全的同时，要注意保证其不存在内存泄露问题</p>

<h4>启动RunLoop</h4>

<p>   主线程的RunLoop是默认启动运行的，非主线程的RunLoop在获取后，需要调用RunLoop的相关run方法或者直接往runloop中添加输入源、定时器、观察者等来启动。</p>

<pre><code>//相关的run方法
- (void)run;
- (void)runUntilDate:(NSDate *)limitDate;
- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate *)limitDate;
//给runloop添加定时器、输入源的方法
- (void)addTimer:(NSTimer *)timer forMode:(NSRunLoopMode)mode;
- (void)addPort:(NSPort *)aPort forMode:(NSRunLoopMode)mode;
//给runloop添加observer
    NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];
    CFRunLoopObserverContext  context = {0, self, NULL, NULL, NULL};
    CFRunLoopObserverRef    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,
            kCFRunLoopAllActivities, YES, 0, &amp;myRunLoopObserver, &amp;context);
    if (observer)
    {
        CFRunLoopRef    cfLoop = [myRunLoop getCFRunLoop];
        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);
    }
//观察者的回调方法
void MyRunLoopObserver(CFRunLoopObserverRef observer,
                       CFRunLoopActivity activity,
                       void* info)
{
    NSLog(@"INFO");
    switch (activity) {
        case kCFRunLoopEntry: {
            NSLog(@"即将进入Loop");
            break;
        }
        case kCFRunLoopBeforeTimers: {
            NSLog(@"即将处理Timmer");
            break;
        }
        case kCFRunLoopBeforeSources: {
            NSLog(@"即将处理Source");
            break;
        }
        case kCFRunLoopBeforeWaiting: {
            NSLog(@"即将进入休眠");
            break;
        }
        case kCFRunLoopAfterWaiting: {
            NSLog(@"刚从休眠中唤醒");
            break;
        }
        case kCFRunLoopExit: {
            NSLog(@"即将退出Loop");
            break;
        }
        case kCFRunLoopAllActivities: {
            NSLog(@"所有的状态");
            break;
        }
    }
}
</code></pre>

<p> 直接通过run方法启动RunLoop时需要注意，在适当的时机给RunLoop添加事件源（source／timer／port）来触发RunLoop一直运行，保证其不会随着线程退出而退出。这个适当的时机是指在当前非主线程还没有退出之前，给RunLoop添加了事件源（source／timer／por／performselecter方法等t）即可，添加事件源与调用run方法之间没有顺序的限制。只要保证是在当前这个非主线程执行过程中。同时在非线程执行perfomrslector，必须保证其它线程有一个活跃的runloop也是同样的道理 <br/>
 不通过run相关方法，直接创建定时器和输入源，也需要通过上面列出的方法添加到当前runlooop上<br/>
  通过下面的demo，在三种方式之间切换，可以验证上面的结论</p>

<pre><code>@interface StartRunloopVC ()
@property (nonatomic, strong) NSThread *thread;
@end
@implementation StartRunloopVC
- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor lightGrayColor];
    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(createRunloop) object:nil];
    [self.thread setName:@"liangfang-thread"];
    [self.thread start];
    //方式二，在run之后，保证runloop不会退出
//    [self performSelector:@selector(performsel) onThread:self.thread withObject:nil waitUntilDone:NO];
}
- (void)createRunloop
{
    NSRunLoop *runloop = [NSRunLoop currentRunLoop];
    //方式一，在run之前，保证runloop不会退出
//    [runloop addPort:[NSMachPort port] forMode:NSRunLoopCommonModes];
    [runloop run];
    NSLog(@"如果当前线程的runloop没有退出，则此处一直不会执行");
}
- (void)performsel
{
    NSLog(@"perform方法");
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event
{
    NSLog(@"进入系统的下一次循环");
    //方式三，下面是一个反例，下面的performsel方法永远不会执行，因为self.thread对应的runloop即线程已经退出了
    [self performSelector:@selector(performsel) onThread:self.thread withObject:nil waitUntilDone:NO];
}
</code></pre>

<p>原理：内部源码实现实际是通过do while() 循环来实现的</p>

<h4>退出RunLoop</h4>

<p>主线程的RunLoop是一直不会退出的，除非应用结束，非主线程RunLoop的退出有两种方式<br/>
（1）通过给RunLoop配置一个超时值，设置超时值的方式如下，此时就不能使用run了<br/>
- (void)runUntilDate:(NSDate <em>)limitDate;<br/>
- (BOOL)runMode:(NSRunLoopMode)mode beforeDate:(NSDate </em>)limitDate;</p>

<pre><code>//在非主线程执行下面方法，doFireTimer方法执行10此之后，当前线程就退出了
[NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(doFireTimer) userInfo:nil repeats:YES];
[runloop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
</code></pre>

<p> （2）通过调用 CFRunLoopStop 方法来退出，但是自己通过demo试了当前非主线程还是存在，好奇怪，官方文档说可以<br/>
  <img src="../images/runloop2.png" alt="Alt text" /></p>

<h3>RunLoop的不同模式及模式切换</h3>

<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer，如下图示：<a href="http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png">http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png</a></p>

<p>系统默认注册了5个Mode，其中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）、NSEventTrackingRunLoopMode、NSRunLoopCommonModes（kCFRunLoopCommonModes）是比较常用的，其它的Mode一般是系统在使用。</p>

<p>DefaultRunLoop：默认的mode，主线程相关的事件响应等都在defaultmode下<br/>
EventTrackingRunLoop：滑动界面，如scrollview的滑动监听在此mode下<br/>
CommonMode：默认包含了所有的mode，譬如想让定时器在界面滑动的时候也生效，可以将定时器添加到commommode下，而不是defaultmode</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/git-xue-xi-bi-ji/">Git 学习笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-15T11:09:27+08:00'><span class='date'>2016 年10 月15 日</span> <span class='time'>11:09 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Git 原理</h3>

<h4>版本控制系统</h4>

<p>版本控制系统目前有三大类，分别是本地版本控制系统、集中式版本控制系统、分布式版本控制系统，Git则是一个非常强大的分布式版本控制系统
   <img src="../images/git1.png" alt="Alt text" /></p>

<h4>Git分布式版本控制实现</h4>

<p>（1）首先从git远程仓库克隆下来的是整个仓库文件的完整拷贝<br/>
（2）在本地修改文件，进行提交之前会保存修改文件的完整快照，而不是只保存差异变化或者文件补丁，对于当前版本没有修改的文件，会保存指向上一个版本该文件的指针（即未变化的文件只会保存上一个版本的指针），这样随着版本越来越多，git所占用的空间不会越来越大。<br/>
SHA-1 校验和<br/>
（3）如果把git存储的文件通过key-value的形式表示，value即表示文件内容，key就是文件内容与文件头信息的SHA-1 校验和（一种加密算法，计算出的是一个不可逆的数值，用于验证文件是否被修改过），即我们常说的commit号（也称为文件的指针），git在这里使用SHA-1 校验和主要是为了保证数据的完整性，即用这个独一无二的commit号来表示当前版本的完整信息，如果当前版本的文件做了一点点修改，计算出的commit号就会不一样（雪崩效应？）。 因此，每一个版本的文件都有唯一的commit号（唯一的指针）</p>

<p>文件(blob)对象，树(tree)对象，提交(commit)对象<br/>
（4）如果将git中每一个文件用blog来表示，所有文件通过tree来进行管理，类似下图所示的关系，每一个结点都有一个 SHA-1 指针，当这个结点的文件被修改并提交时，会生成一个新的blog文件结点以及新的唯一SHA-1 校验和，同时将此次提交的文件指针指向新的SHA-1 校验和，对于没有被修改的结点，则文件指针保持不变，不会生成新的blog结点
<a href="https://static.lufficc.com/image/8f108375134643622b7e9273520eed91.png">https://static.lufficc.com/image/8f108375134643622b7e9273520eed91.png</a><br/>
（5）前面讲到了commit号，其实commit号不仅包含SHA-1 校验和信息，还包括作者、当前提交时间等信息，并且在一个版本中，commit代表的是树结点中最顶层的tree结点，参考下图，第一个First Commit对应了一个Test.txt文件，第二个Second Commit对这个文件进行了修改，因此生成了一个新的blog结点，以及添加了一个新文件的结点，第三个Third Commit没有对这些文件进行修改，因此文件指针指向上一个commit的blog结点。注意图中，除了第一次每个提交对象都有一个指向上一次提交对象的指针。<br/>
<a href="https://static.lufficc.com/image/092c08d87d63ff0a804356705ce01c4b.png">https://static.lufficc.com/image/092c08d87d63ff0a804356705ce01c4b.png</a><br/>
总结：blog结点就是文件内容，tree结点就是用来管理blog结点和子tree结点的，commit结点用来管理每次提交最顶层的tree结点，并且包含作者、提交时间、上一次提交的commit等信息。</p>

<p>Git引用<br/>
（6）如果我们要通过commit号回退到某个经常使用版本，记住这个版本的commit号是一件很不现实的问题，但是如果给这个commit号起一个别名，则比较容易记住，这个别名专业术语叫引用。相关引用与commit号的对应关系存储在.git/refs文件夹中</p>

<h3>远程仓库使用（注意与本地仓库进行区分）</h3>

<p>   方式一：git clone git地址  克隆一个远程仓库到本地，会在本地当前目录下创建一个和远程仓库一样的文件夹，testlf。进入这个文件夹，就可以看到➜  testlf git:(master) . 用git管理项目的标识<br/>
   方式二：git init   对当前文件夹下的文件用git进行管理。会在当前文件夹下生成一个.git的隐藏文件。但是没有与任何远程仓库关联。那如何与远程仓库进行关联呢？<br/>
    1、git remote add pb git://github.com/paulboone/ticgit.git   //本操作含义：添加一个新的远程仓库，可以指定一个简单的名字,还没有进行任何关联，一般默认的仓库名是origin<br/>
     2、git fetch pb  / /抓取所有 Paul 上的数据。完成这个操作，Paul 的主干分支（master）已经完全可以在本地访问了，对应的名字是 pb/master<br/>
     3、你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新 （本地仓库和远程仓库的内容就相当于两个分支了，还要自己去尝试做）<br/>
    总结：不过我觉得一般开始管理远程仓库，都会先在远程上创建一个仓库create repository。然后将他clone到本地。在这个仓库对应的本地文件夹下创建项目，或者将要用git管理的工程复制到这个项目下，就可以对它add。。。等的操作进行管理和push到远程仓库了。并且本地所做的任何更改，都可以提交到远程仓库。</p>

<h4>git本地操作的三个区域</h4>

<p>（1）工作区、暂存区 、本地版本库，这三个区域中工作区表示现在修改代码所在的区域，比较抽象一些，暂存区即运行git add命令后文件保存的区域，本地版本库就是本地的这个仓库，下面通过在本地对文件进行增删改的操作以及git status命令来理解这三个区域，git status命令的作用后面有详细介绍<br/>
（2）增加文件：通过git status查看，它是Untracked files（未跟踪的文件）－》工作区。运行git add－》暂存区。再运行git commit－》本地版本库。如果在暂存区的时候对这个文件进行了修改，通过git status查看，该文件一个还在暂存区Changes to be committed，一个在工作区Changes not staged for commit。<br/>
（3）修改文件：通过status查看，它是Changes not staged for commit:－》工作区。运行git add－》暂存区，再运行git commit－》本地版本库。如果在暂存区对这个文件进行修改，结果与前面也是一样的。<br/>
（4）删除文件：如果是手动删除或者使用［rm 文件名］删除，通过status查看，Changes not staged for commit－》工作区。运行git rm 文件名－－》暂存区。再运行git commit－》本地版本库，该文件就不再纳入版本管理<br/>
（5）总结，在工作区，文件有可能是新增加未跟踪的，有可能是修改未暂存，有可能是暂存后又修改未暂存的，有可能是跟踪后暂存然后修改未暂存的。也可以把这三个区域理解为一种状态，要与他实际的工作区域对应上，则从本地仓库中出现了的修改和变化的角度去分析。<br/>
（6）整个工作流包含以下三步：第一步在工作区域增加、删除、修改文件，第二步执行git add，把改动保存到暂存区域，第三步执行git commit，将所做的改动永久保存到本地版本库中，第四步git push，将本地版本库修改同步到远程版本库。</p>

<h3>Git 常用命令</h3>

<pre><code>git status ：方便我们查看本地文件的状态以及文件所在的工作区域, 可以用 gst 简写
git rm --cached readme.txt  要移除跟踪但不删除文件，即从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件比较适合
git mv file_from file_to  对文件改名
 git push origin :refs/tags/1.3.4  git删除远端tag
 git tag -d 1.3.4     git删除本地tag
 git push --delete origin 远程分支名   git 删除远程分支
区分远程仓库与本地仓库
git push origin 本地分支名:refs/heads/远程分支名  提交本地分支到远程分支, （有时候报找不到远程分支等的情况， 可类似加上refs/heads/）
git branch --set-upstream 本地分支名 origin/远程分支名   本地分支关联到远程分支
git remote -v  查看本地关联的远程仓库地址
git init    对当前文件夹下的文件用git进行管理。会在当前文件夹下生成一个.git的隐藏文件, 此时还没有和远程仓库进行任何关联
git remote add 修改后的仓库名 远程仓库地址  （修改后的仓库名不写的情况下，仓库名默认与远程一致，一般默认的仓库名是origin）
git clone 远程仓库地址   克隆一个远程仓库到本地，会在本地当前目录下创建一个和远程仓库一样的文件夹

git branch 分支名   //新建一个分支
git branch     //查看当前分支清单，分支前的＊号表示当前所在分支
git checkout 分支名   //切换到相应分支， 注意：切换分支的时候最好保持一个清洁的工作区域。切换到下一个分支之前，保证工作区、暂存区的内容都已经提交。不然会混淆。并且它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支
git checkout  -b 分支名  //将前面新建分支和切换分支的命令结合起来
git remote set-url 本地仓库名 远程仓库地址    //修改本地关联的远程仓库，为新的远程仓库地址
git init    //将本地的代码纳入到git版本控制
</code></pre>

<h3>本地分支的新建与合并</h3>

<pre><code> （1）基本命令
  git branch 分支名   //新建一个分支
  git checkout 分支名   //切换到相应分支
  注意：切换分支的时候最好保持一个清洁的工作区域。切换到下一个分支之前，保证工作区、暂存区的内容都已经提交。不然会混淆。并且它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支
  git branch   //不加任何参数，可以查看当前分支清单，分支前的＊号表示当前所在分支
  git branch -v //查看各个分支最后一个提交对象的信息
  git branch --merged  //查看已经合并的分支
  git branch – no-merged  //查看没有合并的分支
  git branch -d 分支名 //可以删除已经合并了的，如果删除没有合并的，会提示错误
  git branch -D 分支名  //强制删除没有合并的分支
 （2）分支指针
   master分支指针
   创建新的分支，就相当于创建了一个新的分支指针。
   head指针：切换分支时，指向你当前工作的分支
  画分支关系图的时候，主干分支横着画，创建的新分支竖着画，这样理解更清晰一些，如果一个分支下还有多个分支时，也可以竖着并行排列即可。
   （3）分支合并
   比较容易出现的一种情况即，在某个分支下新建一个分支后，做了很多次提交。而（从原来分支远程pull数据下来的时候，或者本地去做了一些修改的时候）原来的分支页进行了提交，并且可能与其他分支进行了merge操作，如下所示：
</code></pre>

<h3>解决合并冲突</h3>

<p>$ git merge iss53<br/>
Auto-merging index.html<br/>
CONFLICT (content): Merge conflict in index.html<br/>
Automatic merge failed; fix conflicts and then commit the result.<br/>
并且停下来等你解决冲突，可以用 git status 查阅：并且会显示未解决冲突的具体文件。直接打开相应文件，用vim进行手动修改即可</p>

<p>可以看到 很多等号 隔开的到 很多尖括号 HEAD的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容。下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。<br/>
最后 尖括号和等号 这些行是需要手动删除的。下面是选其一的方式解决冲突</p>

<p>运行 git add 将把它们标记为已解决状态 ，再运行一次 git status 来确认所有冲突都已解决，就可以提交了。</p>

<h3>版本回退命令</h3>

<p>   git reset &ndash;hard HEAD^<br/>
 因为Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交（通过git log／git log &ndash;pretty=oneline）可以查看提交的commit号。上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。  <br/>
回退到相应版本之后，查看相应文件，就会发现也会回到之前修改的状态。通过git log查看版本库也会发现。回退版本之前的版本都没有了。<br/>
1、如果想回到之前最新的版本，怎么办，只要命令行终端没有关闭，找到之前git log查看的相应版本的commitid，然后使用下面的命令即可<br/>
git reset &ndash;hard 命令号（取前几位就可以了），然后再查看相应文件，发现又回到最新的了。<br/>
2、如果关闭电脑，关闭命令行终端后，想回到之前最新的版本，怎么办,使用git reflog  就可以查看每一次命令的记录，然后就可以找到相应版本的commitid号</p>

<h3>总结</h3>

<p>   HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset &ndash;hard commit_id。<br/>
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。<br/>
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>

<h3>远程分支的理解和使用</h3>

<p>远程分支的表示形式： (远程仓库名)/(分支名)<br/>
创建远程分支方法<br/>
      （1）我是在本地执行如下命令时，git push origin master:new-remote-branch，如果远程没有一个名为new-remote-branch的分支，系统就会自动创建一个origin/new-remote-branch的远程分支了。<br/>
git push (远程仓库名)  (本地分支名) : (远程分支名)<br/>
 （可以将本地的某个分支提交到远程的任意一个分支，这个分支就默认跟踪了这个远程分支），</p>

<pre><code>➜  gcdTestForGit git:(master) git push origin master:new-remote-branch
Counting objects: 4, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 353 bytes | 0 bytes/s, done.
Total 4 (delta 2), reused 0 (delta 0)
remote: 
remote: Create pull request for new-remote-branch:
remote:   git分支
remote: 
To git地址
 * [new branch]      master -&gt; new-remote-branch
➜  gcdTestForGit git:(master) 
</code></pre>

<p>   （2）跟踪某个远程分支 方法：  从远程分支 checkout 出对应的本地分支，即相当于在本地创建一个与远程一样的分支，进行跟踪      <br/>
      创建方式：
      git checkout -b master origin/master     ／／从远程分支新建并切换到master 本地分支，其内容同远程分支 origin/master 一致，这样你就可以在里面继续开发了 。其实这些在git clone  的时候git都给我们做好了。但是如果是其他git add 的远程分支，我们就需要手动去做这些操作。</p>

<pre><code>➜  gcdTestForGit git:(master) git checkout -b test-link-remote origin/new-remote-branch  
Branch test-link-remote set up to track remote branch new-remote-branch from origin.
Switched to a new branch 'test-link-remote'
➜  gcdTestForGit git:(test-link-remote) 
      git checkout --track origin/master    ／／1.6.2 以上版本的 Git，对上面第一种创建方式进行简化。要为本地分支设定不同于远程分支的名字，就使用第一种方式换个名字即可。
  作用：1、跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。
       2、同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。
  注意：如果要在特定的远程分支中工作，提交数据，必须先按照上面的方式在本地先跟踪这个分支（比如development分支），然后在这个本地分支下再新建分支（如bugfix/mybranch，进行操作，完成后提交到远程的bugfix/mybranch分支，最后在远程合并到development分支
 实例操作：
  我们可以通过创建很多个本地分支来追踪某个远程分支。然后每次push，都自动提交到这个远程分支下。最后master分支可以将远程分支合并。
</code></pre>

<h3>合并两个远程分支</h3>

<p>如上面例子所示：合并origin/master   与  origin/new-remote-branch .解决相应冲突即可(解决冲突的方法见上面）
    ➜  gcdTestForGit git:(master) git merge origin/new-remote-branch
    Auto-merging gcdTestForGit/test1.txt
    CONFLICT (content): Merge conflict in gcdTestForGit/test1.txt
    Auto-merging gcdTestForGit/test.txt
    CONFLICT (content): Merge conflict in gcdTestForGit/test.txt
    Automatic merge failed; fix conflicts and then commit the result.
    ➜  gcdTestForGit git:(master) ✗
    具体解决冲突如下：
    ➜  gcdTestForGit git:(master) ✗ git status
    On branch master
    Your branch is up-to-date with &lsquo;origin/master&rsquo;.
    You have unmerged paths.
      (fix conflicts and run &ldquo;git commit&rdquo;)</p>

<pre><code>Unmerged paths:
  (use "git add &lt;file&gt;..." to mark resolution)

 both modified:   test.txt
 both modified:   test1.txt

no changes added to commit (use "git add" and/or "git commit -a")
➜  gcdTestForGit git:(master) ✗ vim test.txt
➜  gcdTestForGit git:(master) ✗ vim test1.txt
➜  gcdTestForGit git:(master) ✗ git status
On branch master
Your branch is up-to-date with 'origin/master'.
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add &lt;file&gt;..." to mark resolution)

 both modified:   test.txt
 both modified:   test1.txt

no changes added to commit (use "git add" and/or "git commit -a")
➜  gcdTestForGit git:(master) ✗ git add .
➜  gcdTestForGit git:(master) ✗ git status
On branch master
Your branch is up-to-date with 'origin/master'.
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

 modified:   test.txt
 modified:   test1.txt

➜  gcdTestForGit git:(master) ✗ git commit -m 'submit-git-test-10' 
[master 95552e2] submit-git-test-10
➜  gcdTestForGit git:(master) gi status
zsh: command not found: gi
➜  gcdTestForGit git:(master) git status
On branch master
Your branch is ahead of 'origin/master' by 3 commits.
  (use "git push" to publish your local commits)
nothing to commit, working directory clean
➜  gcdTestForGit git:(master) git push origin master
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 545 bytes | 0 bytes/s, done.
Total 5 (delta 2), reused 0 (delta 0)
To git分支  master -&gt; master
➜  gcdTestForGit git:(master) 
</code></pre>

<h3>删除远程分支</h3>

<p>git push [远程名] :[分支名]<br/>
  其实它是省略了《git push [远程名] [本地分支]:[远程分支]》命令中的本地分支。即提取一个空白的本地分支到远程分支。所有一定要注意这个两个命令的区别。使用git push命令做提交操作时一定要注意，如果写了（：），一定要加本地分支名</p>

<p>问题：如果某个本地分支没有与远程分支关联，（在master分支下，好像默认跟踪的master，还是），可以push到别的远程仓库吗？<br/>
如下：在master下创建一个分支，在本地做修改并且做了commit提交，但是没有push。<br/>
然后把它push到别的远程分支会是什么情况？</p>

<pre><code>➜  gcdTestForGit git:(test-local-branch) git push origin test-local-branch:new-remote-branch
Counting objects: 4, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 363 bytes | 0 bytes/s, done.
Total 4 (delta 3), reused 0 (delta 0)
remote: 
remote: Create pull request for new-remote-branch:
remote:   git分支
remote: 
To git地址
   103f55f..852a6ea  test-local-branch -&gt; new-remote-branch
➜  gcdTestForGit git:(test-local-branch) 
</code></pre>

<p>结果：test-local-branch分支变成了跟踪new-remote-branch远程分支的一个本地分支
并且切换到远程分支new-remote-branch中，可以看到在本地test-local-branch分支中做的修改，说明push成功了。<br/>
结论：在本地创建一个分支的时候，（跟踪某个远程分支的作用是可以fetch／pull这个远程分支的数据，不跟踪貌似也能拉取它的数据，所以我觉得本地分支和远程分支在push之前好像没有很大联系），在push操作之前，一定要对远程分支进行fetch／pull的操作拉取新的更新数据，然后push。<br/>
好像push fetch pull的时候都不会出现冲突（push就是把本地的覆盖远程的，fetch／pull远程覆盖本地的），只有merge的时候才会有冲突。</p>

<p>所以在做项目时应该是每个人创建属于自己的远程分支（所以push都只覆盖自己），然后某个人去把这个远程分支进行merge时再去解决冲突。最后可能就把merge后的分支再与主远程分支merge
下面这篇博客讲了多人协作开发中git在不同场景下的使用，可以多看看，多试着练习一下，博客最后有人提了一个问题，其实也是我不太懂的。就是怎么建远程分支，好像我前面都是建本地分支时设置一个远程分支，然后就自动生成， 问了一下我们项目时开一个task的时候，可以在那个网页上建远程分支就可以了。
<a href="http://limboy.me/tech/2011/02/25/git-workflow-with-blog-demo.html">http://limboy.me/tech/2011/02/25/git-workflow-with-blog-demo.html</a></p>

<p>下面是我做的一次练习测试，加深我对git多人协作开发流程的理解</p>

<p>在当前分支下，提交多次。并且push到对应的远程分支</p>

<p>git:(new-remote-branch) git push origin new-remote-branch。结果如下所示</p>

<p>然后利用版本回退，回到前面的第二个commit
git:(new-remote-branch) git reset &ndash;hard HEAD~2</p>

<p>此时还会提示你要git pull远程上的commit，但是你想把前面的两个commit都删除。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git status
On branch new-remote-branch
Your branch is behind &lsquo;origin/new-remote-branch&rsquo; by 2 commits, and can be fast-forwarded.
  (use &ldquo;git pull&rdquo; to update your local branch)
nothing to commit, working directory clean</p>

<p>这时又在这里做了多次commit。即出现分支的分化（分叉），直接push的话，git会默认对这些分支进行一个merge。如果有冲突就会出现错误，不知道是不是的。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) vim test1.txt
➜  gcdTestForGit git:(new-remote-branch) ✗ git add .
➜  gcdTestForGit git:(new-remote-branch) ✗ git commit -m &lsquo;submit-08-14-06&rsquo;
[new-remote-branch cfb560b] submit-08-14-06
 1 file changed, 1 insertion(+), 1 deletion(-)</p>

<p>如下图所示</p>

<p>再做一次和前面一样的commit操作，得到如下</p>

<p>其实上面的图显示的告诉你，可以git merge来合并。但是如果我直接push的话，看一下会出现什么结果.果然出错了。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git push origin new-remote-branch
To git地址
 ! [rejected]        new-remote-branch -> new-remote-branch (non-fast-forward)
error: failed to push some refs to &lsquo;git地址&rsquo;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: &lsquo;git pull &hellip;&rsquo;) before pushing again.
hint: See the &lsquo;Note about fast-forwards&rsquo; in &lsquo;git push &ndash;help&rsquo; for details.</p>

<p>然后运行git status，提示你要先pull</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git status
On branch new-remote-branch
Your branch and &lsquo;origin/new-remote-branch&rsquo; have diverged,
and have 2 and 2 different commits each, respectively.
  (use &ldquo;git pull&rdquo; to merge the remote branch into yours)
nothing to commit, working directory clean
git pull之后就会告诉你有哪些冲突，然后解决冲突后就可以了。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git pull
Auto-merging gcdTestForGit/test1.txt
CONFLICT (content): Merge conflict in gcdTestForGit/test1.txt
Automatic merge failed; fix conflicts and then commit the result.</p>

<p>最后解决冲突，然后commit push之后，就可以了</p>

<p>➜  gcdTestForGit git:(new-remote-branch) ✗ vim test1.txt
➜  gcdTestForGit git:(new-remote-branch) ✗ git add .
➜  gcdTestForGit git:(new-remote-branch) ✗ git commit -m &lsquo;submit-08-14-08&rsquo;
[new-remote-branch 3dd204d] submit-08-14-08
➜  gcdTestForGit git:(new-remote-branch) git push origin new-remote-branch
Counting objects: 12, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (12/12), 1.00 KiB | 0 bytes/s, done.
Total 12 (delta 9), reused 0 (delta 0)
remote:
remote: Create pull request for new-remote-branch:
remote:   git分支
remote:
To git地址
   c66c1bc..3dd204d  new-remote-branch -> new-remote-branch</p>

<p>但是如果想强制将分叉本地分支覆盖掉远程分支上。而submit－08-14-04和submit－08-14－05两次commit的操作都删除的话，使用git push origin new-remote-branch。即加一个－f的参数。就可以不记性pull然后解决冲突了。</p>

<p>总结：通过上面的实验，让我明白了在一个分支上一直commit push的话，直接覆盖前面的。只有当在这个分支上（如回退到某个分岔点）出现分岔的时候才需要merge等的操作，就可能需要解决冲突。所以很多人在一个远程分支上工作的时候。一般如果有人push了，则你在本地想要push
的时候，先运行git status，一般就会告诉你先git pull，然后如果没有冲突你再push就可以了。如果是你一个人在远程分支上工作貌似就没关系。</p>

<p>git rebase的理解：修改当前分支的基底分支，在基底分支上重演一遍分支中所做的修改，这个命令执行后不会出现马上要解决冲突，因为它还是生成了一个分支，只有从新的基底分支merge这个分支的时候才可能出现要解决冲突。</p>

<p>［第一部分］
<a href="http://blog.csdn.net/u010520912/article/details/18993001">http://blog.csdn.net/u010520912/article/details/18993001</a>
创建github账号及上传代码的步骤
github账号地址
<a href="https://github.com/amyliangfang/lf/blob/master/c-01/c-01">https://github.com/amyliangfang/lf/blob/master/c-01/c-01</a>
具体步骤：
注册github账号－使用ssh密钥认证－创建本地仓库并上传代码到github</p>

<p>参考书籍：
<a href="http://git-scm.com/book/en/v2">http://git-scm.com/book/en/v2</a></p>

<p><a href="http://pcottle.github.io/learnGitBranching/">http://pcottle.github.io/learnGitBranching/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/nsurl-loading-system/">NSURL Loading System</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-05-07T15:45:29+08:00'><span class='date'>2016 年5 月7 日</span> <span class='time'>3:45 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>1、概述</h3>

<p>NSURL Loading System主要用来描述使用标准internet协议与server端交互，以及与URLs进行交互的基础框架类。它是一组类和协议的集合，允许你的app去获取URL指定的内容，核心类即NSURL，通过它使我们的app可以操作URLs以及URLs指向的资源。</p>

<p>除了NSURL，这个基础框架还提供了包括加载URLs、上传数据到服务器、管理cookie存储、控制返回数据的缓存、处理证书存储和身份验证、编写自定义的协议扩展等一套丰富的功能集合。</p>

<p>NSURL Loading System主要支持通过以下协议来获取相应资源，包括文件传输协议、超文本传输协议、超文本加密传输协议、本地文件url传输协议、Data URLs传输协议（<a href="ftp://">ftp://</a>   <a href="http://">http://</a>  <a href="https://">https://</a>  file:///  data://），同时支持代理服务器和socks网关。</p>

<p>除了NSURL Loading System，iOS还支持其他API可以在其他应用如safari中打开网页等，即通过在UIApplication中使用openURL:打开相关URL，具体可参考UIApplication Class Reference.</p>

<p>NSURL Loading System包含了一系列helper类来协助URL loading类完成加载过程和相关行为，主要可以分为以下5大类，即协议支持、身份验证与证书、cookie存储、配置管理、缓存管理，如下图链接</p>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Art/nsobject_hierarchy_2x.png</a></p>

<h3>2、URL Loading</h3>

<p>URL Loading是在NSURL Loading System中通过url获取相关内容使用最普遍的一个类，你可以通过很多种方式获取相关内容，这依赖于你app的需求、app系统版本，以及你是否希望以文件的形式获取数据，还是以内存的形式获取。</p>

<p>在iOS7及之后的版本，推荐使用NSURLSession API来执行URL请求，如果相应应用必须支持旧的版本，你可以通过NSURLConnectionx下载数据到内存，然后根据需要看是否将数据写入磁盘，或者使用NSURLDownload下载数据到磁盘文件，你选择的方法很大程度上依赖于你希望获取数据到内存还是磁盘文件。</p>

<h3>如何使用NSURLSession</h3>

<p>概览：NSURLSession及其相关类主要提供了通过http实现下载功能的API。提供了包括支持请求认证、后台下载（app在没有运行状态、暂停状态下的一些）等功能。这些功能都通 过其代理方法获取。</p>

<h3>理解NSURLSession的基本概念</h3>

<p>一个session中tasks的行为依赖于三件事情：session的类型（依赖于创建时配置对象的类型），task的类型，当task创建的时候app是否在前台。</p>

<h4>1.session的类型</h4>

<p>Default sessions（默认）：与其它下载url的基础方法非常相似，使用了持久的基于磁盘的缓存，并且将认证信息存储到用户的keychain里面。</p>

<p>Ephemeral sessions（短暂）：它不存储任何数据到磁盘，所有的缓存、认证信息等都存储在RAM 随机存取存储器中与session进行关联，当app的session失效时，它们会自动清除。</p>

<p>Background sessions（后台）：与默认session非常相似，除了它需要使用一个单独的进程来处理所有的数据传输，并且它在某些方面存在着一些限制。</p>

<h4>2.task的类型</h4>

<p>data tasks：用于发送和接受NSData类型的对象，适用于与服务端的短暂频繁交互的客户端请求。返回的数据可以通过一个comletion handler block一定时间内的部分或者所有的数据。</p>

<p>download tasks：以file文件的形式获取数据，并且支持app没有运行时的后台下载</p>

<p>upload tasks：以file文件的形式上传数据，并且也支持app没有运行时的后台上传</p>

<h4>3.后台数据传输的注意事项</h4>

<p>对于Background sessions，由于实际的数据传输是i通过一个进程来执行的，并且重新启动app的过程相对代价也很大，有很多features功能也不可用，因此会存在如下一些限制：</p>

<p>（3-1）session必须提供一个event delivery事件交互的delegate，delegate的行为和当前进程数据传输过程保持一致</p>

<p>（3-2）仅仅支持http和https协议（不支持custom protocols）</p>

<p>（3-3）Redirects are always followed（重定义一直存在？）</p>

<p>（3-4）仅仅支持file文件格式的上传任务（上传data类型或stream类型的对象在程序退出时会失败）</p>

<p>（3-5）如果后台数据传输是在程序处于后台的时候初始化的，configuration配置对象的discretionary属性会设置为true。</p>

<p>注意：在iOS 8 and OS X 10.10之前，data tasks 不支持Background sessions。</p>

<p>对于iOS 和 OS X，在app重新启动时，处理方式也有细微差别。</p>

<p>在iOS中，当一个后台数据传输任务完成或者需要鉴权，如果你的app不在运行状态，iOS会在后台自动重启你的app，并且调用当前app的UIApplicationDelegate 对象的application:handleEventsForBackgroundURLSession:completionHandler: 方法，这个调用方法提供了引起当前app启动的session的 identifier 标识符信息，当前你的app应该存储completion handler信息，并且用同样的identifier创建一个background configuration object，并且用这个configuration object创建一个session，新的session就会自动与正在进行的后台任务建立关联。接下来，当session完成最后一个下载任务，它会给session代理发送一个URLSessionDidFinishEventsForBackgroundURLSession:消息，在这个代理方法中，切换到主线程上调用之前存储的completion handler，让你的操作系统知道 重新suspend 挂起你的app也是安全的。
同样的在iOS 和 OS X中，当用户重启你的app，对于上一次运行时的 outstanding tasks，你的app应该马上创建针对这个tasks的相关session，并且保证创建的background configuration object的identifier与相应session是一一对应的。这些新创建的session同样会自动与正在进行的后台任务建立关联，并且新下载文件的url会与此进行关联，</p>

<p>注意：你必须准备的创建每一个identifier对应的session，多个session共享同一个identifier的行为是undefined不支持的。</p>

<p>当你的app处于suspended挂起状态，有task 任务执行完成，则会调用task的URLSession:downloadTask:didFinishDownloadingToURL:代理方法。
同样的，如果task需要鉴权等认证过程，NSURLSession对象会调用它的URLSession:task:didReceiveChallenge:completionHandler: 代理方法，或者是URLSession:didReceiveChallenge:completionHandler:代理方法。
在出现网络错误的情况下，background sessions中的上传和下载任务，会由URL加载系统自动重试，不需要使用可达性api来确定何时重试失败的任务</p>

<p>对于使用NSURLSession的后台传输任务的例子，可以参考Simple Background Transfer.</p>

<h3>生命周期及与代理的交互</h3>

<p>充分理解session的生命循环，对于处理NSURLSession相关的任务是非常有帮助，包括session怎样与它的代理交互，代理方法调用的顺序，如果server端返回一个重定向会发生什么，当你的app恢复一个错误的下载会发生什么，等等，关于NSURLSession生命周期的完整描述，参考Life Cycle of a URL Session</p>

<h3>NSCoping行为</h3>

<p>session和task对象都遵循如下的NSCoping协议：
当你的app拷贝了一个session或者task对象，会返回一个同样的对象
当你的app拷贝了一个configuration对象，会返回一个你可以独立修改的新的对象</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/reactive-cocoaxue-xi-bi-ji/">Reactive Cocoa学习笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-02-18T23:40:18+08:00'><span class='date'>2016 年2 月18 日</span> <span class='time'>11:40 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>入门</p>

<h3>一、信号RACSignal</h3>

<pre><code> 单个信号的创建方式
（1）RACObserve观察成员变量值的信号，前提是该属性必须支持KVO
（2）RAC封装UI控件事件输入值变化传递的信号
（3）通过RACSignal类方法创建的信号
（4）将某个信号赋值给某个成员变量，也就是信号绑定
（5）对信号进行链式和过滤生成一个新的信号

 组合信号

 通过RACSignal的类方法combinelatest将上面的单个信号进行组合

  基本概念和用法

  信号的生命周期：RACSignal从创建到在block中发送sendNext sendCompleted.以及－对信号执行delay、等操作－被订阅者订阅subscribeNext subscribeCompleted的过程。类似于一个工厂，该工厂只有在消费者需要某个产品［somesignal subscribernext ］时，工厂才会去生产相应产品，即执行相应代码［subscriber sendnext：somedatat］，这样的信号被称为冷信号，还要一种热信号可以参考http://tech.meituan.com/tag/ReactiveCocoa#rd


  创建自定义的RACSignal，实现方式，
  Signal获取到数据后，会调用Subscriber的sendNext, sendComplete, sendError方法来传送数据给Subscriber，Subscriber自然也有方法来获取传过来的数据，如：[signal subscribeNext:error:completed]。可以这样理解，RACSignal需要传入一个实现RACSubscriber协议的类，并且会调用相应协议的方法sendNext...。而这些相应协议方法的实现在subscribeNext...等的block中，相当于subscribeNext...替换sendNext...协议方法的实现，改了一下方法名称，本质是在subscribeNext...封装的方法中对协议方法实现进行了一些处理。具体可参考后面的分析。

  注意这个方法带有三个参数这样只要没有sendComplete和sendError，新的值就会通过sendNext源源不断地传送过来，举个简单的例子：
   RACSignal *signal = [RACSignal createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) {
NSLog(@"triggered");
[subscriber sendNext:@"foobar"];
[subscriber sendCompleted];
return nil;
}];

[RACObserve(self, username) subscribeNext: ^(NSString *newName){
NSLog(@"newName:%@", newName);
}];

 可以在上面的方法后直接添加error completed参数的block，也可以分开写，如下所示：
 [signal subscribeCompleted:^{
NSLog(@"subscription %u", subscriptions);
 }];

    如果有多个subscriber的订阅者，那么signal就会又一次被触发，控制台里会输出两次triggered。这或许是你想要的，或许不是。如果要避免这种情况的发生，可以使用 replay 方法，它的作用是保证signal只被触发一次，然后把sendNext的value存起来，下次再有新的subscriber时，直接发送缓存的数据。 并且当一个信号存在多个订阅者时，也有可能产生的副作用。譬如，在一个block中修改外面的__block变量的值，会对后面的订阅者获取到的这个值产生影响。
</code></pre>

<h3>二、相关实例代码</h3>

<pre><code>// KVO
[RACObserve(self, username) subscribeNext:^(id x) {
NSLog(@" 成员变量 username 被修改成了：%@", x);}];
// target-action
self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {
 NSLog(@" 按钮被点击 ");
 return [RACSignal empty];}];
 // Notification
 [[[NSNotificationCenter defaultCenter]rac_addObserverForName:UIKeyboardDidChangeFrameNotificationobject:nil]subscribeNext:^(id x) {
 NSLog(@" 键盘 Frame 改变 ");}];
 // Delegate
 [[self rac_signalForSelector:@selector(viewWillAppear:)] subscribeNext:^(id x) {
 debugLog(@"viewWillAppear 方法被调用 %@", x);}];
</code></pre>

<p>注意事项：</p>

<pre><code>（1）RACObserve使用了KVO来监听property的变化，只要username被自己或外部改变，block就会被执行。但不是所有的property都可以被RACObserve，该property必须支持KVO，比如NSURLCache的currentDiskUsage就不能被RACObserve

（2）rac_textSignal是RAC为UITextField添加的category，只要usernameTextField的值有变化，这个值就会被返回(sendNext)。combineLatest需要每个signal至少都有过一次sendNext

 （3）UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"" message:@"Alert" delegate:nil cancelButtonTitle:@"YES" otherButtonTitles:@"NO", nil]; 
 [[alertView rac_buttonClickedSignal] subscribeNext:^(NSNumber *indexNumber) {     
  if ([indexNumber intValue] == 1) {         
     NSLog(@"you touched NO");     
   } else {         
     NSLog(@"you touched YES");     
  } }]; 
  [alertView show];

 （4）有了这些Category，大部分的Delegate都可以使用RAC来做。或许你会想，可不可以subscribe NSMutableArray.rac_sequence.signal，这样每次有新的object或旧的object被移除时都能知道，UITableViewController就可以根据dataSource的变化，来reloadData。但很可惜这样不行，因为RAC是基于KVO的，而NSMutableArray并不会在调用addObject或removeObject时发送通知，所以不可行。不过可以使用NSArray作为UITableView的dataSource，只要dataSource有变动就换成新的Array，这样就可以了。

 （5）说到UITableView，再说一下UITableViewCell，RAC给UITableViewCell提供了一个方法：rac_prepareForReuseSignal，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都addTarget:action:forControlEvents，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：
 [[[self.cancelButton
rac_signalForControlEvents:UIControlEventTouchUpInside]
takeUntil:self.rac_prepareForReuseSignal]
subscribeNext:^(UIButton *x) {
// do other things
}];
</code></pre>

<h3>三、RACTurple RACStream RACSubject  RACScheduler RACSubscriber</h3>

<pre><code>  （1）在Objc下，输入输出的“值”都可以用id类型，遇到多个值的组合就用RACTurple
  （2）  RACStream作为一个描述抽象的父类，它定义的几个基本方法自己并没有实现，是由具体子类来实现，RACStream的两个子类分别是RACSignal和RACSequence，可以对应到下面的图进行理解。
  （3）RACSubject(继承自RACSignal，可以理解为自由度更高的signal)。比如一个异步网络操作，可以返回一个subject，然后将这个subject绑定到一个subscriber或另一个信号。
   - (void)doTest
{
RACSubject *subject = [self doRequest];

[subject subscribeNext:^(NSString *value){
    NSLog(@"value:%@", value);
}];
}

  - (RACSubject *)doRequest
 {
RACSubject *subject = [RACSubject subject];
// 模拟2秒后得到请求内容
// 只触发1次
// 尽管subscribeNext什么也没做，但如果没有的话map是不会执行的
// subscribeNext就是定义了一个接收体
[[[[RACSignal interval:2] take:1] map:^id(id _){
    // the value is from url request
    NSString *value = @"content fetched from web";
    [subject sendNext:value];
    return nil;
}] subscribeNext:^(id _){}];
return subject;
 }

 （4）对RACScheduler作用的理解，先 通过下面的文字了解了它的作用，还没有写具体代码
 RACScheduler是RAC里面对线程的简单封装，事件可以在指定的scheduler上分发和执行，不特殊指定的话，事件的分发和执行都在一个默认的后台线程里面做，大多数情况也就不用动了，有一些特殊的signal必须在主线程调用，使用-deliverOn：可以切换调用的线程。
订阅者执行时的block一定非并发执行，也就是说不会执行到一半被另一个线程进入，也意味着写subscribeXXX block的时候没必要做加锁处理            However, RAC guarantees that no two signal events will ever arrive concurrently. While an event is being processed, no other events will be delivered. The senders of any other events will be forced to wait until the current event has been handled.

 (5) RACSubscriber是定义的一个协议，参照博客http://nathanli.cn/2015/08/27/reactivecocoa2-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/的内容，对它理解的更加深入，自己总结如下：
  RACSubscriber协议定义了sendNext sendError sendCompleted 等方法，首先明白协议使用的两个条件：1 有类实现了协议的方法 2 其他类中定义了协议对象，调用了协议的方法。在源码中的体现就是RACSignal里面（创建方法等方法中）封装了对这个协议方法的调用，在RACSignal的订阅方法subscriber中传入一个实现了协议方法RACSubscriber的对象。即外部要订阅这个信号就必须实现RACSubscriber协议中的方法，实际就是对订阅的值进行处理（在一层协议方法中在嵌套一层协议方法）。  其次源码对实现协议中方法的对象进行了一些封装，将协议方法的实现转化为block。更进一步将前面封装的block实现的类作为RACSignal的一个分类方法，这样对外部隐藏RACSubscriber，直接对订阅值value进行一些处理。

   - (void)nl_subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock {
   NLSubscriber *subscriber = [NLSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];
  [self subscribe:subscriber];
 }

   前面的分析只是明白了 RACSignal内部给我们封装好了 RACSubscriber这个协议的使用，还应该要明白 RACSignal它最重要的方法 [self subscribe:subscriber];的实现细节。可以在源码里面看看下面这个方法试的实现细节
  @interface RACSignal (Subscription)
  /*
  *  `subscriber` 订阅 receiver 的变化。由 receiver 决定          怎么给 subscriber 发送事件。
  *简单来说，就是由这个被订阅的信号来给订阅者 subscriber 发送 `sendNext:` 等消息。*/
   - (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber;
   @end

   在博客中完全从订阅者RACSubscriber （即先不考虑信号是怎么发送的）以及 设计模式的角度详细描述了它的实现过程，如下
   （1）定义了一个协议RACSubscriber ，申明它的三个方法sendNext sendError sendCompleted。定义一个实现这个协议方法的具体类，如NLSubscriber
   （2）在RACSignal的分类 (Subscription)中，定义一个subscribe方法，需要传入一个实现了RACSubscriber协议的类。如上面方框中代码所示。

    通过上面两步，我们就可以简单的定义一个RACSignal 一个NLSubscriber，并且把NLSubscriber传给RACSignal分类 (Subscription)中的subscribe方法。
   但是这样有一个问题就是，如果有多个订阅者，每个订阅者都要创建一个类，实现RACSubscriber协议以及协议的方法。因为每个订阅者的实现方法有很多种，很难实现复用。对于在某些场景中，譬如某个算法的实现，它的实现方式只可能是固定的几种方式（或者说几种策略，可称为策略模式），我们可以通过这种方式去实现，但是对于多个订阅者的实现方式不能复用的情况，用上面的方法就不是很好。解决办法是使用block，将协议的实现方法用block来代替。
</code></pre>

<p>上面的实现类似策略模式，下面类似适配器模式。</p>

<pre><code>  （1）定义一个实现RACSubscriber协议的通用类，在这个通用类中，定义与协议方法实现相关的block，并且作为这个通用类的属性，在通用类的初始化方法中给这些block属性传值，同时在协议方法实现中去执行这些block。
   这样，我们可以通过定义一个RACSignal，一个通过block初始化的通用类，将这个通用类传入RACSignal分类 (Subscription)中的subscribe方法。这样实现通过block的方式去定义i 不同的实现，而不需要去定义多个不同的类去实现了。
   源码中在上面的基础之上，将通用类的初始化，以及传给subscribe方法的过程封装到了RACSignal的一个分类方法中，只需要在参数定义中把对应的block传递过去即可。对于用户来说只需要创建RACSignal对象，调用它的sendNext...等方法，同时调用subscribeNext...等方法完成前面调用方法的具体实现。并且后面有实现的情况下触发前面的调用，与这个相关的实现细节应该在RACSignal源码的具体实现中去分析。
</code></pre>

<h3>四、注意事项</h3>

<pre><code>  （1）RAC 在应用中大量使用了 block，由于 Objective-C 语言的内存管理是基于 引用计数的，为了避免循环引用问题，在 block 中如果要引用 self，需要使用@weakify(self)和@strongify(self)来避免强引用。另外，在使用时应该注意 block 的嵌套层数，不恰当的滥用多层嵌套 block 可能给程序的可维护性带来灾难。
  （2）RAC在使用时有一些注意事项，可以参考官方的DesignGuildLines。
  （3）当一个signal被一个subscriber subscribe后，这个subscriber何时会被移除？答案是当subscriber被sendComplete或sendError时，或者手动调用[disposable dispose]。当subscriber被dispose后，所有该subscriber相关的工作都会被停止或取消，如http请求，资源也会被释放。
  （4）Signal events是线性的，不会出现并发的情况，除非显示地指定Scheduler。所以-subscribeNext:error:completed:里的block不需要锁定或者synchronized等操作，其他的events会依次排队，直到block处理完成。
  （5）Errors有优先权，如果有多个signals被同时监听，只要其中一个signal sendError，那么error就会立刻被传送给subscriber，并导致signals终止执行。相当于Exception。生成Signal时，最好指定Name, -setNameWithFormat: 方便调试。
  （6）block代码中不要阻塞。
</code></pre>

<p><a href="http://limboy.me/">http://limboy.me/</a>
<a href="http://blog.sunnyxx.com/tags/Reactive%20Cocoa%20Tutorial/">http://blog.sunnyxx.com/tags/Reactive%20Cocoa%20Tutorial/</a></p>

<p>进阶</p>

<h3>一、RAC原理</h3>

<pre><code>   关于原理性的知识应该在一开始学习的时候就要深刻理解的， 但是刚开始学总会好高骛远，总想着马上就会用了，其实虽然学会了一些简单的用法了，一到比较难的知识点理解起来就比较困难了，就是因为一开始没有理解它的根本原理。下面是经过RAC培训之后自己的总结。

   RAC来源于FRP（函数式响应式编程）思想：随时间变化的数据流在这个思想的基础上还有ReactiveX By Microsoft，它的一些基本操作与RAC也是比较类似的，http://rxmarbles.com/ 

   而RAC是通过订阅者的方式来控制数据流的开始时间点，结束时间点，并且通过一些方式对随时间变化的数据流做一些控制（过滤，整合等）。

   比较常见的一种场景，对网络请求返回数据的订阅，如果是冷信号，会导致网络请求数据的操作执行多次，而如果是热信号，可能会产生一定的副作用或者数据不一致，感觉在这种有网络请求的场景下使用信号要特别注意。如何正确的使用它，防止它不犯错误。
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/swift-xue-xi-zong-jie/">Swift 学习总结</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-01T14:33:03+08:00'><span class='date'>2016 年1 月1 日</span> <span class='time'>2:33 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Swift学习之基础部分</p>

<pre><code>   常量和变量,主要掌握根据它们使用的场景，对不会变化的值使用常量，对不断变化的值使用变量。

   注释：单行注释使用//，对于多行注释还可以使用嵌套。

   分号：Swift中可以省略分号，如果在同一行有多条语句，需要用分号隔开。

   整数：Int UInt 可以通过它的最大值、最小值属性获取它表示的范围。

   浮点数：带有小数点的数据类型，Float Double。

   类型安全和类型推断：Swift会在编译的时候对代码进行类型检查，把不匹配的类型标记为错误。如果给变量或常量赋了初始值的时候，可以不申明类型，由系统进行类型推断。由此想到swift中两个基本概念，隐式类型推断和隐式类型可选的异同点），相同点：在使用这些特性的时候都有前提条件，隐式类型推断的前提条件是这个变量被赋予了初始值或者没有赋初始值但是指定了变量的类型。隐式类型可选的前提条件是在某些程序中，某个变量第一次被赋值之后，可以确定一个可选类型总会有值。不同点：隐式类型推断是编译的时候就会检查，隐式解析可选是在运行时的时候才会对尝试在隐式解析可选没有值而进行取值的情况检查。
</code></pre>

<p>1、基础数据类型（通常都是通过结构体或枚举类型定义的）</p>

<pre><code> 常量定义 let  i ＝ 10，常量一般必须要赋一个初值

 变量定义 var j : Int ，变量如果指定类型可以不赋初值,如果没有指定类型必须赋初始值

 它们的共同特点就是可以不指定值的类型。如果没有指定类型编译器会根据你赋的值进行类型推断。

 总结：Swift支持隐式类型推断，不支持隐式类型转换（把某种类型的值赋值给另一种类型的值）。
</code></pre>

<p>2、swift新增的数据类型</p>

<pre><code> 元组（tuples)
 可选值
 隐式解析可选 
</code></pre>

<p>3、字符串数据类型</p>

<pre><code>   首先理解字符串存储由来，我们都知道计算机只能识别0101的数字，那一些非数值类型的字符是如何存储的呢，首先需要制定一些统一的标准，将符号转化为数字，由此出现针对英文字符的ASCII编码，但是全世界除了英文，还要中文，俄文等等其他语言，ASCII编码已经不能满足我们的需求，因此出现一个支持全世界各种语言的国际标准Unicode标准，而swift就是支持Unicode标准的一门语言，并且它的变量名也是支持中文的。
</code></pre>

<p>4、运算符</p>

<pre><code>   与其他语言的区别，一个赋值运算符整体构成的表达式不代表一个值，不能进行连续赋值a＝b＝1，并且赋值运算符也不能出现在if判断语句中了，如果出现就会报错，这样也能避免我们把==写成＝，而不报错的情况出现。
   还有另外一个区别，swift新增了一种区间运算符，定义如下：0...5 表示0，1，2，3，4，5。0...&lt;5 表示0，1，2，3，4。有一个需要注意左右区间不能用小数，否则会出现一直循环。
</code></pre>

<p>5、集合数据类型</p>

<pre><code>   数组：相同类型的数据在数组中连续排列，因为是有序，元素检索速度非常快（c语言数组定义）。Swift数组的定义与此类似，还是有很多差别。定义如下：var array1 : Array&lt;Int&gt; = ［1,2,3,4］,因为数组中元素类型定义为范型，我们可以定义为任意一种类型。 并且Swift的数组中可以放置任意类型的数据。通过设置它的类型为Any，如下：var array1 : Array&lt;Any&gt; = ［“hello”,2,3,4］，至于它为什么能存储不同数据类型，可以从数组的结构体定义以及存储上去找原因。并且Swift允许在结构体中声明方法，更符合面向对象思想。

   数组操作：读数据，通过数组下标的方式，同样也要注意数组越界的问题。修改数据，前提数组是变量，可以通过append、insert等向数组中添加一个元素，或者以直接赋值的方式修改数组中某个元素，以及通过removeLast、removeAtIndex删除数组中的某个元素。

   slice：一种与数组非常相似的集合类型，定义也差不多一样，和数组可以进行相互转换，如：Slice sli = array1[0...5] 通过区间运算符或者使用Slice的结构体方法定义 Slice sli = Slice(array1)，不能直接赋值

   range：用来存放区间表达式的值，它的本质是结构体，它也支持泛型（即任意类型，但也必须遵守forwardindex协议），var range : Range&lt;int&gt; = 0...3 或者通过构造方法定义 var range2 : Range&lt;int&gt; = Range(start:0, end:3)，需要注意的是这里表示0，1，2，不包括3。而前面的定义包括3.

   数组批量操作，前面讲的slice、range都是为数组的批量操作做准备的。

   (1) 可以将range指定范围内的数替换成任意其他个范围内的数，var array1 = ［1,2,3,4］array1[0...1] = ［8,7,8,9]。最后得到的array1为:［8,7,8,9,3,4]。或者使用函数array1.replaceRange(Range(start:0, end:2), With:[8,7,8,9]).，实现和前面一样的结构

   (2) 数组还可以通过复合的赋值运算符往数组中添加元素、数组、slice等，array1+=9 等价于 array1.append(9)，array1+＝[1,2,3]，array1+=slice，array1+=array2[0...5]
  数组遍历，第一种for in 快速枚举，第二种通过元组进行遍历
 for elem in array1{
 println(elem)
 }
 for  (index, value) in enumerate(array1){
   println("index:\(index) = \(value)");    //其中\(index)类似于对字符串中格式化占位符的处理
  }
</code></pre>

<p>6、字典数据类型</p>

<pre><code>  基本概念，存放无序的数据，因此它的遍历需通过检索数据关键字实现，它类似于数据结构中hash函数和hash表的概念，首先根据key和hash函数计算出一个地址，addr = hash(key)，然后从hashtable中根据这个地址获取到key对应的值，value ＝ hashtable(addr)。所以key首先是必须可hash的，在swift中可hash，即需要遵守一个协议，一般的基本数据类型string、int、float等都遵守相应协议，因此，一个字典中它的key值也可以是多样的。 如：var dict ＝ ［”1“:a，2:b]
  字典操作，读：println(dict["1"])  写：dict[2] = 8 修改：dict.updatevalue(9,forkey("1"))。需要注意修改操作返回的是一个可选值，如果key存在，会替换key对应的值，并且返回key对应的之前的值，如果key不存在，会向字典中增加一个这个不存在key所对应的值，相当于往字典中添加了一个新的值，并且返回nil。删除：dict.removevalueforkey("1")，同样，如果存在这个key，就删除相应key对应的值，同时返回旧的value值，如果不存在这个key旧不做任何操作，返回nil。字典遍历，即类似元组遍历，同时也可以遍历所有key，或者所有value
 if let orignal = dict.updatevalue(9,forkey("1")){
    println("new:\(dict["1"])");
    println(orignal);
 }
 if let orignal = dict.removevalueforkey("1"){
    println(original)
 }
 for (key,value) in dict{
    println("\(key):\(value)")
  }
  for key in dict.keys{
     print(key)
  }
  for value in dict.values{
     println(value)
  }
</code></pre>

<p>7、swift中语句的基本用法</p>

<pre><code>   if语句，以及if中多分支执行语句，我们知道程序不可能只有一种执行顺序，因为实际生活中往往存在多种选择或者循环问题，下面从程序指令执行过程的角度考虑：
    顺序指令：比较好理解，选择指令：有些指令被执行，有些指令不会执行，循环指令：某些指令会循环不断的被执行。将这三种指令相结合，可以解决我们实际生活中的绝大部分问题。
    其中if else、while、for in、break、continue语句的使用与OC语言都非常相似，要特别注意的是switch语句与其他语言的switch语句有一些差别，主要区别为三点，
     （1）最后必须加default 
     （2）可以去掉break了，oc中如果case语句后面不加break，会造成switch贯穿执行，即匹配到某一个case选项后，后面的所以case的语句都会被执行，而在switch中，不需要显示添加break，它匹配到case后，会自动退出。
     （3）case后面可以添加多个匹配条件，如case “a","b" 类似于或，只要有一个满足要求即可。
     （4）因此，switch支持广义匹配，匹配类型可以是整形、区间运算符、元祖、通配符（如_，表示任意一个字符），实例如下。
     （5）switch具有值匹配模式特性，在第三个例子中，case中的let x let y表示：x y可取任意值，一旦有值，会把它绑定到x y中，赋给x y，x y页可以为常量，［let x， let y］与［let（x，y）］两者的写法是等价的。在case匹配语句使用值绑定的情况下，可以在后面加上where 条件，加上值绑定模式的匹配条件。
  let x = 1000 
  swich x｛
     case 1...9 :
     println("个位数");
     case 10...49:
     println("十位数")
  default:
     println("不符合")
  ｝

 let point = (10,10)

  switch point ｛
   case (0,0) :
   println("坐标原点")
   case (1...10, 1...10) :
   println("x,y坐标位于1-10之间")
   case(_, 0) :   
    println("点在x轴")
  default :
   println("其他")
  ｝

   swith point ｛
     case (let x ,10)
     println(x)
     case let(x, y)
     println("\(x):\(y)“）
     case let x, let y
     println("\(x):\(y)“）
    case let (x, y) where x == -y
    println("\(x):\(y)“）

  //返回两个顶点的长和宽
  let po = (double, double) = (0,0)
  let p1 = (double, double) = (8,8)
  fun getlengthandwidth(p0:(double,double),     p1(double,double)) -&gt; (length:double, width:double) ｛
   return (abs(p0.0-p1.0), abs(p0.1-p1.1))
   }

   let w = getlengthandwidth(p0, p1).width
   let h = getlengthandwidth(p0, p1).length
   //这里要通过名称访问元祖的某个元素，要定义返回值元组中每个元素的名称
</code></pre>

<p>8、函数的相关概念</p>

<pre><code>   定义：完成某个特定功能的代码块，该代码块可重复使用。
   语法：func 函数名(参数名:参数类型,参数名:参数类型,...) -&gt; 函数返回值类型 ｛      //函数实现部分      ｝     
   调用语法：函数名（实际参数...）   函数名遵循驼峰命名法 ，可以有多个参数，多个返回值，也可以没有参数没有返回值（没有返回值时，可以不写-&gt;,或者写-&gt; void）。实例代码如上面第四个例子所示，
   内部参数与外部参数概念：因为函数的定义实现与函数的调用是分开的，因此当我们看到某个函数调用的代码或者想要调用某个函数时，希望通过参数名就可以了解传递参数的含义，而不用去看函数的定义和实现。因此swift提供了一个外部参数，我们在调用函数的时候可以显示对这个外部参数赋值，这样函数的参数信息一目了然。类似于oc中通过方法名帮助我们理解参数含义，

   swift中则通过外部参数帮助我们理解函数传入参数的含义，实例代码如8-1所示，注意：函数实现部分，只能使用内部参数。如果内部参数和外部参数想使用同一个名字，即一个参数即表示内部参数又表示外部参数，可在参数名前面加上＃，进行标识

   如果你不设置函数的外部参数名，但是调用函数的时候默认会把内部参数名作为外部参数名，但是第一个参数不会，如下所示
   func test(first:Int, second:Int)
   {
     print("hello");
    }
   test(1, second: 2)

   如果想在调用函数的时候想省略第二个外部参数名，即加上下划线_即可
   如下所示
  func test(first:Int, _ second:Int)
  {
     print("hello");
   }
  test(1, 2)


 func divisionoperation(dividend a:double, divisor b:double) -&gt; double ｛
  return a/b
 }
 let res = divisionoperation(dividend:3.5, divisor:1.2)
 func joinstring(s1:string, tostring s2:string, joiner s3:string = "#") -&gt; string ｛
 return s1+s2+s3
}
 let str = joinstring("hello", tostring:"world")
 func swap(a:int, b:int){
   let t = a
   a = b //这里会报错
   b = t
 }


     函数默认值参数概念：
     即对函数中的某个参数指定默认值，相应在调用时可以不给这个默认值参数赋值，有一个需要注意的：当带有缺省值或默认值的这样一个参数，如果只有一个参数名，内部参数名将作为外部参数名使用，因为调用函数，修改其参数默认值，必须使用其外部参数名，否则报错，因此，在函数默认值参数的定义中，如果只定义了内部参数名，没有定义外部参数名，编译器会把默认值参数的内部参数名当作外部参数名使用，这属于编译器做的一个优化，实例代码如8-2所示，注意：对比c++中默认参数必须写在函数参数列表最尾部，不能移到参数列表前面，但是swift中现在是可以的，即可以出现在参数列表的任一位置。

    常量参数与变量参数概念：
    默认函数的参数是常量类型，即只可以读，不可以写或者进行修改操作，如图8-3的使用，编译器会报错，我们可以把它定义为var类型，就可以修改了inout参数的使用：主要用在输入输出函数中，首先看8-4的代码,调用 swap(x,y)之后，最后的输出结果x还是10，y还是28，我们一般会认为x y值应该变化，其实并没有，它实际执行是将10赋值给a，19赋值给b，实际只修改了a b，没有修改x y，在c语言中也同样存在这样的问题，c语言的处理方式是可以 传递x y变量的地址，相应在swap函数中申明a b为指针。但是swift中没有指针，因此引入了一个inout关键字，通过这个关键字修饰参数。改进后的代码如8-5所示：注意：调用swap函数使用&amp;符号不是c语言中取地址的含义，而是将x y变量赋值给函数a b参数。总结：如果我们希望一个函数能修改外部的变量，首先在函数定义时需把参数定义为inout，输入输出参数类型，其次传递实参时需在变量前面加一个&amp;的形式传递过去，等价于a是x的引用，b是y的引用，传递的时候是把x y整个变量都传递过去，而不只是传递变量对应的值10 28，通过&amp;x &amp;y与inout a inout b的配合，最终达到修改函数传递参数的目的。注意：符号&amp;后面不能直接跟一个具体值，需要传一个变量名。

 func swap(var a : int, var b : int){
   let t = a
   a = b
   b =t }

  var x = 10
  var y =  28
  swap(x,y)
  func swap(inout a : int, inout b : int){
   let t = a
   a = b
   b =t }

  var x = 10
  var y =  28
  swap(&amp;x,&amp;y)
  func add (array : [int] -&gt; int ｛
  var sun = 0
  for i in array ｛
    sum +=i
   }
  println(add([1,2,3,4,5]))
  for array(array : int...) -&gt; int ｛
  var sum = 0
  for i in array ｛
    sum += i
   ｝
  println(add(2,3,4))
   fun add (a:int, b:int) -&gt; int ｛
   return a+b
   ｝
  fun sub (a:int, b:int) -&gt; int ｛
   return a-b
  }
 变参参数，即参数个数可以是不确定的，要实现变参参数，我们首先想到的可能是通过数组的形式实现，如8-6实例代码所示，在swift中对变参参数进行了定义，语法格式为，参数名：参数类型...  ,只需要修改变量类型，即在参数个数不确定，但是参数类型都是一致的情况下可以这样使用，即把它当作一个数组（集合），并且 在调用时不用传数组，而是像调用函数一样，传递任意个相应类型的参数，如8-7所示，函数实现不变，并且在调用函数时做一些修改即可。注意：变参函数中变参必须放在参数列表最后面。

 函数类型：（参数、返回值类型）类型相同的函数定义如下：函数参数类型以及返回值类型都一样只是实现不一样。如8-8所示，可以将上面的两个函数抽象出公共的函数类型（int, int) -&gt; (int)，可以对这个函数类型做如下的一些定义。
 定义一个函数类型常量或变量：var calfunc: (int, int) -&gt; int = add，这样非常类似c语言中函数指针以及oc中的block，申明这样一个变量有一个好处即可以对它重新赋值，calfunc = sub println(calfunc(3,5)，此时得到是sub函数计算的结果。因为一个函数类型的变量非常灵活，它可以指向相同类型的其他函数，可以达到c语言中函数指针及oc中block一样的功能。
 函数类型作为一个参数，如8-9所示，将其关联。


 func subcalfunc(a:int, b:int, #op:(int, int) -&gt; int) ｛
  return op(a, b)
}
println(subcalfunc(20.35,op:sub)
  func max(a: int, b:int) -&gt; int ｛
  return a&gt;b?a:b
 ｝
func min(a:int, b:int) -&gt; int ｛
  return a&gt;b?b:a
｝
func choosefunc(#getmax:bool ) -&gt; (int, int) -&gt; (int)｛
 return getmax?max:min
 ｝
     var myfunc:(int, int) -&gt; (int) =    choosefunc(getmax:true)
  println(myfunc(2,9))
  func funcname(参数) -&gt; 返回值类型 ｛
 执行语句
｝
｛ （参数) -&gt; 返回值类型 in 
  执行语句
｝
 let sayhello:() -&gt; void = ｛
   println("hello word")
  }  //无参闭包，() -&gt; void可以不写
  sayhello()
 let add:(int, int) -&gt; (int) = ｛
  (a:int , b:int) -&gt; int in 
   return a+b
  }   //有参闭包，
 println(add(3,5))

函数返回一个函数类型的返回值：当根据输入参数判断执行哪一个函数时使用，如8-10所示
</code></pre>

<p>9、闭包的基本概念</p>

<pre><code>    闭包：从函数的定义来理解，完成某个特定功能的代码块，在swift中可以理解为闭包是一个更轻量级的函数（自包含的函数代码块），可以把函数分为三大类（1）全局函数（有名函数）。（2）闭包表达式（匿名），能捕获上下文中的常量或者变量，牵涉到内存管理，值捕获。(3)嵌套函数。

    闭包表达式的定义、申明和使用，与函数的区别，闭包没有函数名，但是它还是由参数类型和返回值类型构成，并且参数类型和返回值类型是写在大括号里面的，并且还有注意加一个关键字in，如果没有参数和返回值可以不加in，如9-1所示，上面是函数定义，下面是闭包定义。理解闭包表达式它实际也是有类型的， 在swift中很多都可以称之为一个类型，而类型又可以定义一些常量或变量。如9-2所示。上面的用法只属于非典型性用法，因为这些用法跟函数的使用还没有很多区别。

    闭包表达式的回调用法：即闭包比较典型的用法，下面9-3是一个冒泡排序的实例代码，对它进行改造，将array[j] &gt; array[j+1]的比较通过闭包实现，假设这个比较需要处理比较多的内容，得到9-4所示代码，在9-4的bubbleSort2(&amp;array, intCmp)方法中，还可以把intCmp方法的实现代码直接移过来，不定义为变量。如果要修改比较策略，譬如字符串比较，数字最低位比较，可以只修改闭包函数。类似于block回调，我们可以定义多种block函数的实现，调用bubblesort只需要告诉它一个排序数据以及排序策略。相比于函数来说，闭包可以省略函数名，直接函数实现。通过闭包、block实现多种变化的功能，我们可以传递闭包表达式的多种不同实现，至于闭包表达式何时被调用，是由外层的函数决定的。

func showArray(array:[Int]){
for x in array{
    print("\(x)")
}
print("")
}

  func bubbleSort(inout array:[Int]){
let cnt:Int = array.count
for var i = 1; i &lt; cnt ; i++ {
    for var j = 0; j &lt; cnt - i; j++ {
        if (array[j] &gt; array[j+1]){
            let t = array[j]
            array[j] = array[j+1]
            array[j+1] = t
        }
    }}
 }

 var array = [6,5,9,3,5,2,10]
 showArray(array)
 bubbleSort(&amp;array)
 showArray(array)
 let intCmp = { (a:Int,b:Int) -&gt; Int in
if a &gt; b {
    return -1
} else if a &lt; b {
    return 1
} else{
    return 0
}
}

 func bubbleSort2(inout array:[Int]){
let cnt:Int = array.count
for var i = 1; i &lt; cnt ; i++ {
    for var j = 0; j &lt; cnt - i; j++ {
        if (intCmp(array[j], array[j+1]) == -1){
            let t = array[j]
            array[j] = array[j+1]
            array[j+1] = t
        }
    }
} }
 showArray(array)
 bubbleSort(&amp;array)
 bubbleSort2(&amp;array, intCmp)
 showArray(array)

 bubbleSort2(&amp;array, {
(a,b) in
if a &gt; b {
    return -1
} else if a &lt; b {
    return 1
} else{
    return 0
}
})


 bubbleSort2(&amp;array, {
if $0 &gt; $1 {
    return -1
} else if $0 &lt; $1 {
    return 1
} else{
    return 0
}
 })

 sort($array,{
return $0 &lt; $1
})
 sort($array,{
  $0 &lt; $1
 })

  9-6-1
  func bubbleSortFunc(inout array: [Int]){
let cnt = array.count
func swapValue(inout a:Int, inout b:Int){
    let t = a
    a = b
    b = c
}
....
  }
   9-6-2
  func getIntFunc(inc :Int) -&gt; (Int) -&gt; (Int){
func incFunc(v: Int) -&gt; Int{
    return inc + v
}
return incFunc
}

 9-6-3
 let incFunc1 = getIntFunc(12)
 print(incFunc1(15))
 func getIncFuc(inc : Int) -&gt; (Int) -&gt; (Int){
var mt = 20
func incFunc2(v:Int) -&gt; Int{
    mt++
    return inc + v + mt }
return incFunc2
}

   闭包表达式的语法优化：
   为什么要优化，如何优化，借用swift强大的类型推断功能，实现闭包表达式类型优化，  （1）在函数中传递闭包表达式时省略类型，前提是函数申明中包含了闭包类型时，可以根据上下文推断，省略闭包参数类型及返回值类型。如9-5所示，（2）进一步优化，参数都可以省略，而是使用$0 $1来代替，如9-5下面所示

  尾随闭包：
  由于闭包表达式主要用于函数回调，在函数调用时，为了表达更清楚，书写更方便，应该将闭包作为函数最后一个参数，即尾随闭包。当闭包的执行语句，只有单个return表达式的情况下，可以简写去掉return，如9-5下面的代码所示。

   嵌套函数：
   在函数内部申明一个函数，并且这个内部函数只能在内部使用，即它的作用域是在内部函数左右开始，往下到它所在函数结束的位置，同时函数通过闭包捕获上下文的值也属于嵌套函数。如9-6所示，嵌套函数仅仅为它所在的函数服务，所以有一个优点就是可以让程序更直观更清楚。

   闭包捕获值定义：
   嵌套／内部函数可以引用不是它自己而是它所在外部函数申明的变量或常量，因此我们需要研究它捕获的原则，捕获的行为。在9-6-2的实例代码中，定义了一个嵌套函数，我们知道在函数内部申明的局部变量它的作用域和生命周期只在调用函数的时候有效，函数调用结束就不生效了，但是在上面这种情况下，inc被返回的嵌套函数保留了，我们可以暂时理解为一个副本，这个过程可理解为一个上下文的捕获。从内存管理和函数调用栈的角度考虑，一般认为inc随着函数getIntFunc的调用结束已经没有了，但是嵌套函数中使用了inc局部变量，我们就称之为值捕获，从9-6-3的例子中，会发现每次调用这个函数，返回值都会加1，说明嵌套函数捕获mt后，相当于拷贝了mt的一个副本，会记录mt上一次的值，我们可以理解为mt相当于incFuc的一个全局变量，我猜想如果mt是self，不做保护措施，就会出现循环引用啦。

   泛型：
   可以创建泛型的函数或者类型，之前对泛型的了解只停留在它的使用，对于如何自己去自定义一个泛型没有想过，看了文档上的例子也还不是太理解，后面还要多看看。以
  func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) {} 这个函数为例,通过&lt;T&gt; 占位类型名 同时指定函数参数的类型，在调用的时候直接传入一个任意类型即可。如果需要传入多个占位类型，可以用逗号隔开，进行如下表示 &lt;T,T&gt;。数组是非常典型的泛型函数，它支持任意类型，现在如果自定义一个特定的数组：栈，就需要使用泛型函数了。


   协议和扩展：
   主要使用关键字protocol和extension来进行定义，它的使用和oc语言差不多（在语法定义上有一些差别，并且swift继承某个类和使用协议的语法是一样的在 : 后面，感觉这样不是很好，只是推荐把父类写在前面），可以将协议名作为一种命名类型来使用的做法还不是很理解（现在理解了，可以把协议类型作为函数参数类型、返回值类型等用法，充分发挥协议的优势，可以灵活的创建和传递同一个方法的不同实现），文档上的例子也标注了这样使用的注意事项。为什么swift的协议中要申明属性呢，与以前只申明方法相比，申明属性有什么好处呢？通常理解实现了协议的类型，该类型中必须拥有协议中相应的属性和方法（即协议只关心必须要有某些属性和方法，不关心属性和方法的具体值和具体实现）。注意：在协议中使用class关键字申明的类属性和类方法，当枚举和结构体实现这个协议时，需要使用static关键字。且协议中的方法不支持默认参数值。

  理解扩展的使用场景：在无法修改源代码，或者修改已有类不可行的情况下，需要对已有的类、结构体、枚举、协议等进行扩展。也可以对协议扩展以及补充某个类型为协议类型。


   枚举和机构体：
   枚举与其他语言的一个区别是它可以定义方法，并且它的语法也有了一些变化。文档上说结构体和类的一个最大区别是结构体是传值，类是传引用，这个概念跟我之前的理解好像有偏差， 还要多看看。


   对象和类：
   对类的定义类似c语言有构造器（有继承关系的情况下，会做以下几步，1、设置子类的属性值，2、调用父类的构造器，3、还可以改变父类定义的属性值等等）和析构函数，创建类的时候不需要标准根类，与oc语言的区别。子类重写父类的方法需要用override标记。可以在类中定义属性的getter和setter方法，注意它的语法格式。同时swift中还多了一个willset和didset的方法概念。方法与函数有一个重要区别，方法的参数名（除了第一个参数以外的其他参数名）需要在调用的时候显示说明，最后提到如何处理变量的可选值，看起来感觉有些怪，这个还要多看看。

   函数和闭包；
   可以通过元组让一个函数返回多个值。并且函数参数可以是一个可变参数（numbers: Int...) ，在函数内部使用时类似于数组。函数可以嵌套，可以作为另一个函数的返回值，可以作为另一个函数的参数。

   可以使用{}来创建一个匿名闭包，使用in将参数和返回值类型申明与闭包函数体进行连接。闭包在很多种情景下可以进行一些简化，如单个语句的闭包可以省略参数返回值类型申明以及in关键字，

   可以使用参数位置$0 $1来直接引用参数。当闭包作为某个函数的最后一个参数时，可以直接跟在括号后面。


   控制流：相比于oc，有一些简化，如if后面的条件和for循环变量括号可以省略，但是语句体的大括号是必须的。有一个问题不是太明白，if语句后面必须跟一个布尔表达式，那为什么可以使用
  if let name = optionalName ｛｝这样的类似语法处理值缺失的情况，其中var optionalName: String? = "hello"是一个可选值。 swift中的switch相对于其他语言更加强大，可以支持任意类型的数据以及各种比较操作。并且它可以省略break语句，但是一定不能省略default。
  可以使用for in 加上元组来遍历一个字典。在循环中可以使用1..&lt;n表示范围，但是不包括上界，使用1...n才包括上界
</code></pre>

<p>相关参考：</p>

<pre><code>  http://special.csdncms.csdn.net/the-swift-programming-language-in-chinese/index.shtml  中文的

  https://itunes.apple.com/cn/book/the-swift-programming-language/id881256329?mt=11 英文的
  遇到一些坑
  在swift中使用uitableview设置它的样式参数时，总是报找不到我输入的plain样式的参数，找了很多原因，结果发现枚举名要加名称前缀或者是点 .Plain UITableViewStyle.Plain。
  如果报下面这样的错误：execution was interrupted, reason: EXC_BAD_INSTRUCTION (code=EXC_1386_INVOP, subcode=0x0)  先直接在控制台输出的打印信息中找原因，通过看控制台，发现是我调用某个函数获取的是可选值，但是我对这个返回值做申明时没有定义为可选值。
  现在又出现了一个问题是，调用oc方法或者oc第三方库的方法，oc中没有可选值的概念，再swift中调用时，看调用提示默认返回的是一个隐式解析可选，按道理使用隐式解析可选是保证他初始一定会有值的，但是结果oc中没有可选值概念调用的时候却没有值，然后调用相应方法一运行就会报错，这个应该怎么处理。需要再对可选链以及oc方法调用进行研究？
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/sdwebimageyuan-ma-xue-xi/">SDWebImage源码学习</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-02T22:28:07+08:00'><span class='date'>2015 年12 月2 日</span> <span class='time'>10:28 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一、SDWebImage库的组成</p>

<pre><code>  1、通过UIImageView分类提供的常用方法

  （1）在UIImageView (WebCache)分类提供的方法中，可以看到这些方法最终都调用了下面这个方法，在这个方法中封装了对图片进行缓存和异步下载的功能
  - (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options completed:(SDWebImageCompletionBlock)completedBlock;
     在这个分类中还提供了与展示动画图片相关的API：- (void)sd_setAnimationImagesWithURLs:(NSArray *)arrayOfURLs;，即设置一组图片的url，并且以动画的形式展示。

  （2）UIImageView (HighlightedWebCache)：这个分类提供了为UIImageView设置高亮图片时调用的方法，这些方法的实现与前面的分类方法类似。
  （3）UIView (WebCacheOperation) 以字典的形式存储与当前UIView相关的key和SDWebImageOperation，用来添加、移除、取消图片的key对应的operation。
  （4）NSData (ImageContentType) 根据image的NSData判断图片的类型
  （5）UIImage (GIF) 提供gif图片处理，以及图片缩放和裁剪的处理方法
  （6）UIImage (MultiFormat)  将通过NSData的分类方法得到的图片类型，进行不同处理
  （7） UIButton (WebCache)  该分类与UIImageView (WebCache)分类的实现是类似的。
</code></pre>

<p>  2、下面分析要实现上面分类方法中图片的缓存和异步下载功能要用到的几个核心类，及其功能</p>

<pre><code>   SDWebImageManager：首先判断从内存缓存和硬盘缓存中查找url对应的图片是否存在，如果都不存在从网络异步下载图片，如果存在使用block进行回调。同时，如果是从网络下载图片，会对这个图片在内存和硬盘进行缓存，如果从硬盘缓存获取也会保存到内存。

   SDImageCache：具体实现前面SDWebImageManager中从内存缓存和硬盘缓存查找图片，以及保存缓存图片等功能，使用了NSCache以key－value的形式实现缓存功能，以图片的url作为缓存的key，当内存不足时会清除缓存图片。相对于字典缓存，它有下面几个优势

  SDWebImageDownloader：提供异步下载图片功能，当缓存中不存在的情况下，并且使用了imageIO来实现图片的渐进加载。

  SDWebImageDownloaderOperation：封装异步下载网络请求的相关功能。

  SDWebImageDecoder：异步对NSData类型的数据进行解压操作，为了避免UIImage的imageWithData函数在画图的时候对Data进行解压消耗内存，提前进行解压操作，以消耗存储空间提高执行时间和效率。

  SDWebImagePrefetcherDelegate 以预先下载图片，方便后续使用，具体差别还需要仔细看一下源码
</code></pre>

<p>二、SDWebImage实现原理及执行流程</p>

<pre><code>   通过给UIImageView添加相应的分类方法，在分类方法中实现相应功能。下面是整理的UIImageView (WebCache)分类的程序执行流程。
   SDWebImage同时也提供了内存清理的功能：通过在初始化的时会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。
   以及内置的下载进度，在block回调方法里面可以根据接受到的数据和总的数据大小看下载进度
</code></pre>

<p>三、SDWebImage的设计思想</p>

<pre><code>1、使用分类为类扩展更多的功能，让使用者使用图片异步加载就好像直接为UIImageView设置image一样，通过一个图片设置方法就封装了很多功能
2、面向对象编程和面向协议编程的有效结合
3、使用了以空间换时间的一些性能优化策略
4、使用imageIO结合URLConnnection，实现相应代理，每次接收到数据时更新图片
</code></pre>

<p>四、SDWebImage的使用和扩展</p>

<pre><code>   如果我们要在下载图片的过程中实现一些其他自定义的功能，可以通过覆写他提供的一些方法来实现
   pod search SDWebImage 搜索到现在版本为：pod 'SDWebImage', '~&gt; 3.7.3'
   关于图片更深入的学习，可参考：http://blog.cnbang.net/tech/2578/

   学习完上面这篇文章后对里面一些知识点还有些不理解，需要自己去求证。
   如：内核缓冲区（高速／低速缓存） 与 用户空间（内存）区别，
   虚拟内存（从硬盘上开辟的一块空间） 和 内存的区别。
   字节对齐（以c语言中的结构体为例，结构体中元素类型可能有多种，如int  float，我们应该以所占位数最大的float类型为标准，给int元素也分配这么大的空间，这样保证struct的所以类型大小都是一样大，并且是对齐的。这样在一片连续空间中查找结构体的各个元素时，只需要按固定大小查找即可，如果不对齐，就需要一个一个判断大小之后再取）。
    那上面讲的位图图像数据会出现多种不对齐的数据吗



 FastImageCache引伸阅读
 前期参考     
 http://www.cocoachina.com/bbs/read.php?tid=162504
 https://github.com/path/FastImageCache
 使用场景：譬如需要展示很多图片的社交类应用，比较直接和传统的方法是，从api中请求图片数据，处理原始的图片去创建期望的大小和类型，并且在设备中存储这些处理的图片。当应用需要展示这些图片的时候，将它们从磁盘加载到内存，展示到image view上或者渲染到屏幕上。
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/cocoapodsshi-jian/">CocoaPods实践</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-27T18:26:33+08:00'><span class='date'>2015 年11 月27 日</span> <span class='time'>6:26 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、cocoapods概念</p>

<pre><code>   用来方便的统一管理项目中引用的第三方库的工具，它的原理是将所有第三方的依赖库放到https://github.com/CocoaPods/Specs远程仓库的pods项目中，让使用cocoapods的项目依赖这 个pods 项目来管理它所引用的第三方库，即使用这个工具将本地项目对第三方库管理的职责转移出去。
</code></pre>

<p>2、cocoapods安装和使用</p>

<pre><code>安装常用命令如下：
ruby -v    //查看当前ruby的版本
sudo gem update --system //升级gem
gem sources -l    //查看ruby镜像的位置，看是否指向http://   ruby.taobao.org/，具体原因可打开链接
sudo gem install cocoapods   //下载安装CocoaPods
pod setup


使用方法：
  （1）终端中，cd到项目总目录，创建podfile文件，指定项目需要依赖的第三方库
  （2）使用pod search &lt;&gt;命令,可以预先查找自己需要的第三方库资源
  （3）创建好podfile文件后，执行pod install ／pod install --verbose命令，执行安装第三方库的操作。如果前面命令的执行速度非常慢，可以使用pod install --verbose --no-repo-update命令替 换，该命令的作用是不把cocoapods远程仓库上的podspec索引文件更新到本地
   (4)  命令执行成功之后，会生成几个新的文件，一定要注意先关闭xcode，此时需要直接打开新生成的.xcworkspace来打开项目了，否则会报错
  （5）如果修改了podfile文件，执行pod update命令即可
</code></pre>

<p>3、podspec文件的作用</p>

<pre><code>  （1）cocoapods上所有第三方库的项目都对应有一个podspec文件，放置在https://github.com/CocoaPods/Specs仓库上，第一次执行pod setup时，就会将这个仓库上所有的这些podsepc索 引文件下载到本地的~/.cocoapods/目录下。
  （2）我们也可以为自己的项目创建podspec文件，不放到cocoapods公有的远程仓库上，放到自己私有的某个git仓库上，只作为本地私有pods使用，创建好之后，其他项目就可以通过指定podspec文件信息来使用本地私有的公 共库，在podfile文件中，添加如下信息。  pod 'LfDemoCode', :podspec =&gt;'http://git.XXX.com/users/liangfang/repos/testlf/LfDemoCode.podspec'
</code></pre>

<p>4、podfile.lock文件的作用</p>

<pre><code>  （1）该文件用于在多人协作开发中，锁定项目中各个依赖库的版本，如果有人多次执行pod install不会更改版本，但是执行pod update就修改podfile.lock文件了，因为，在多人协作开发时，会将 该文件纳入版本控制中，如果有人修改了这个文件，大家都可以同步。
</code></pre>

<p>5、创建cocoapods私有库方法</p>

<pre><code>   通过cocoapods创建自己的私有库，在公司内部供其他项目使用，首先需要具备如下条件：

  （1）创建一个私有的git远程仓库，类似于cocoapods的https://github.com/CocoaPods/Specs仓库，它的作用就是用于存放依赖库的podspec文件，称之为Spec Repo。然后在本地把这个仓库 添加为一个pod repo，在终端执行如下命令：
   pod repo add LFSpecs ssh://git@git.XXX.com/~liangfang/lfspecs.git,其中LFSpecs是指定的私有repo的名字，命令执行成功后，就可以在本地的~/.cocoapods/repos目录 下，看到添加的这个repo的文件夹(这里还看不到文件夹下相应的podspec文件,因为还没有push相应文件)，其他人如果要共用这个repo上传他们的库文件的话，执行相同的命令即可，即也可以在本地push自己的podspec文件。

   （2）创建一个管理项目工程文件的版本控制地址，git仓库或者其他仓库地址都可以，用来存放依赖库实际代码的项目文件，方式一、使用自己已经创建好的现成的一个项目，push到这个版本 控制地址，方式二、使用pod提供的一个命令开始创建项目，如pod lib create LFPodTestLibrary，其中LFPodTestLibrary是指定的项目名字，然后再push到这个版本控制地址。这里主要考虑第一种方式的使用。具体步骤如下：

     第一步：在本地创建一个工程项目PracticeForPodProject，cd到这个工程目录下，执行git init，添加一个远程管理仓库，提交代码到这个仓库
     git remote add origin ssh://git@git.XXX.com/~liangfang/customcreatepodproject.git
     git push origin master 
     这里需要注意的是要保证打开git网址直接打开工程项目的所有文件，不要在所有文件外面再包含一层文件夹，因为pod spec lint验证的时候会报找不到source file文件的错误。一开始我是先git clone远程仓库地址，然后在这个文件夹下创建新的工程文件，就会有一个以工程名命名的总文件夹，这样就出现上面一直验证不通过的问题。

    第二步：创建一个podfile文件，如下所示，添加一些第三方依赖，保存后执行pod install, 成功之后，把相关修改提交到仓库。使用下面的命令给这个项目添加一个tag号：git tag -m “first release”  0.0.1 ,然后使用命令 git push —tags 来推送tag到远程仓库。

source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '9.0'
pod 'ReactiveCocoa', '~&gt; 2.4.2'
pod 'Mantle', '~&gt; 2.0.4'
pod 'SVProgressHUD-0.8.1', '~&gt; 0.8'
pod 'Masonry', '~&gt; 0.6.2'

   第三步：给这个项目添加一个podspec文件，可使用如下命令进行创建：
   pod spec create PracticeForPodProject git地址。
   执行完后就创建了一个podsepc文件，指定git仓库地址,修改相关内容如下, 注意相关信息与前面定义的保持一致，在本地工程主目录下，创建Pod文件夹，以及Pod下的Classes Assets子文件夹，存放相关测试的.h .m 文件。同时从其他项目拷贝一个license文件和readme.md到当前工程主目录下。保存修改的podspec文件，将前面的所以修改先提交到远程仓库，尤其是添加的文件夹以及使用最新的tag号指向你提交到远程的最新版本，然后执行pod lib lint 以及 pod spec lint PracticeForPodProject.podspec .查看验证是否通过，可以加上--no-clean查看具体信息。

 Pod::Spec.new do |s|
 s.name         = "PracticeForPodProject"
 s.version      = "0.0.1"
 s.summary      = "A test for PracticeForPodProject."
 s.description  = &lt;&lt;-DESC
               A test  for PracticeForPodProject in Markdown format.
               DESC
 s.homepage    = "http://git.XXX.com/users/liangfang/repos/customcreatepodproject/browse"
  s.license      = "MIT"
  s.author             = { "liangfang" =&gt; "liangfang@163.com" }
  s.platform     = :ios, "9.0"
  s.source       = { :git =&gt; "ssh://git@git.XXX.com/~liangfang/customcreatepodproject.git", :tag =&gt; "0.0.1" }
  s.source_files  = "Pod/Classes/**/*.{h,m}"
 end

 第四步：在第三步podspec文件验证通过之后，要把所有修改提交到远程仓库，同时还要把podspec文件提交到远程的spec repo,使用如下命令：
pod repo push LFSpecs PracticeForPodProject.podspec //LFSpecs即为前面创建的repo的名字，文件内容中相关字段可参考http://guides.cocoapods.org/syntax/podspec.html#specification。
 提交成功之后，就可以在本地~/.cocoapods/repos目录下以及LFSpecs对应的远程仓库上找到相应podspec文件。通过pod search PracticeForPodProject也可以找到相应工程信息。

 第五步：修改本地的podfile加上如下语句，执行pod install，再重新打开项目工程，就可以看到前面创建的Pods/Classes/.h .m,已经存放到Pods工程的Development Pods/PracticeForPodProject目录下了。每次在Pods工程下新添加了文件，主要要提交到远程仓库。操作方式与前面类似，方便其他项目对他的依赖。

  source 'ssh://git@git.XXX.com/~liangfang/lfspecs.git'
  pod "PracticeForPodProject", :path =&gt; "PracticeForPodProject.podspec"


   （3）下面在一个本地的其他项目中，来测试上面的项目是否可以通过cocoapods来使用，可通过在podfile文件中添加如下语句，如下所示：执行pod install ，再打开项目就可以在Pods工程中的Pods目录下找到依赖的本地的PracticeForPodProject工程

source 'ssh://git@git.XXX.com/~liangfang/lfspecs.git'
pod "PracticeForPodProject", :git =&gt; 'ssh://git@git.XXX.com/~liangfang/customcreatepodproject.git', :commit =&gt; 'd2804be542c'

   （4） 在其他项目中也可以通过 pod ‘PracticeForPodProject’, ‘~&gt;1.0’ 来直接添加了
   （5）关于cocoapods的subspec属性的使用，后面再添加,如果修改了pod里面已存在的文件，不需要pod install，如果新添加了文件需要pod install.
</code></pre>

<p>参考链接</p>

<p><a href="http://objccn.io/issue-6-4/">http://objccn.io/issue-6-4/</a>
<a href="http://guides.cocoapods.org/syntax/podfile.html">http://guides.cocoapods.org/syntax/podfile.html</a>
<a href="http://www.cocoachina.com/ios/20150916/13384.html">http://www.cocoachina.com/ios/20150916/13384.html</a>
<a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/">http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/</a>
<a href="http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/</a>
<a href="https://guides.cocoapods.org/">https://guides.cocoapods.org/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ocdan-yuan-ce-shi/">OC单元测试</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-11-14T22:55:00+08:00'><span class='date'>2015 年11 月14 日</span> <span class='time'>10:55 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>1、XCode自带XCTest框架了解</h3>

<pre><code>   （1）创建一个工程，会自动为你创建一个单元测试的target，特点：文件名都是以tests结尾
   （2）分析一下X...XTests.m文件的内容，首先该类继承自XCTestsCase类，并且有三个方法，它们各自的功能如下：
     setUp方法用于在测试前设置好要测试的方法，
     tearDown则是在测试后将设置好的要测试的方法拆卸掉。
     testExample顾名思义就是一个示例。
    （3）运行单元测试，使用command＋u快捷键，我好像没有想到别的方法
     在这个文件中可以增加其他测试方法，注意方法名都以test开头，保证规范。可以在方法中编写系统提供的18个断言的测试用例。可以参考博客：http://blog.csdn.net/jymn_chen/article/details/21552941，
    （4）也可以新建其他Objective-C test case class的类来编写与上面类似方法的测试用例。
</code></pre>

<h3>2、Kiwi和Specta单元测试框架的对比</h3>

<pre><code>   首先知道这些框架在github上是可以找到的，与其他第三方库Masonry AFNetworking等框架的使用方式其实是差不多的。

  （1）Specta (BDD框架) 
   Specta是基于XCTest进行封装的，使用Specta，需要依赖别的第三方库，因此还要再引入OCmock/OCMockito以及Expecta/OCHamcrest一起配合使用，但是一般都会引入OCMock 和OCHamcrest 这两个一起使用。再加上OHHTTPStubs(http stub打桩)框架，

    目前主要使用Specta＋OCMock＋Expeata＋OHHTTPStubs结合的方式。其中各个框架的作用如下：

    OCMock Or OCMockito ：这两个都是用来mock对象，Stub方法的，区别在于使用OCMock的库比OCMockito的库多，而且文档和教程更加丰富。mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。mock对象,这个虚拟的对象就是mock对象。mock对象就是真实对象在调试期间的代替品。在实际工程中的使用，我的理解是由于在面向对象编程中，需要测试的某个类，往往又依赖于其他的类，而我们不想去真正创建这个类，调用这个类的某些方法，而是模拟mock出一个这样的依赖类，stub它的方法，指定相应方法的返回值。

    Expecta Or OCHamcrest  ： 都是断言的扩展框架，Expecta不成熟，框架还有一些的问题。OCHamcrest更加成熟，而且可扩展性高，可以自定义自己的断言，更灵活。这是网上别人的观点，因为自己还没有尝试做很多实例代码，后面还有待完善。

    OHHTTPStubs：在实际工程使用中主要用于测试model层在进行网络数据请求时，对接口返回数据的处理（数据解析）是否正确。同时用这个工具来模拟从网络请求返回的json数据，这样可以在本地对这个数据进行任意修改来测试，而不是真正去网络请求数据。https://github.com/AliSoftware/OHHTTPStubs

 （2）Kiwi框架

    Kiwi包含了Specta和OCmock以及Expeata所有的功能。

   总结：对于常用的specta和wiki框架，我们可以根据需要进行选择，对于他们各自的优势，还要后面多测试和学习。注意这两个框架不能同时使用，因为网上有人测试，Kiwi与Specta是不能同时在项目中使用的，会Crash。
</code></pre>

<h3>3、框架的使用</h3>

<pre><code>http://www.bubuko.com/infodetail-1030528.html
http://www.cocoachina.com/ios/20150731/12859.html
https://github.com/6david9/WWDC2015
参照网上的一段
  BDD的理念: 不是写代码，而是讲故事。整个故事是由Given…When…Then组成。
  eg：BDD框架Kiwi的一段测试代码:
  describe(@"Team", ^{
  context(@"when newly created", ^{
    it(@"has a name", ^{
        id team = [Team team]; [[team.name should] equal:@"Black Hawks"];
     });
    it(@"has 11 players", ^{
        id team = [Team team]; [[[team should] have:11] players];
     });
});
});

  这个测试用例就是在说Given a Team,When newly created,it should have a name, and should have 11 players，基本上不需要注释就能知道在干嘛
</code></pre>

<p>  结合之前做的基于MVVM框架些的代码，做了一个打桩的测试，大致实现过程</p>

<pre><code> （1）创建ADModelHTTPStub类（.h .m文件），定义打桩的方法，截取符合相应字符串的网络请求的url，对这个请求的url返回本地的一个json文件来模拟返回的数据，前提是在创建好json文件，存放返回的数据
   + (void)stubFetchADInfoSucceed{
[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
    NSRegularExpression *re = [NSRegularExpression regularExpressionWithPattern:@"/test/v3/guanggao"
                                                                        options:0
                                                                          error:nil];
    return [re numberOfMatchesInString:[request.URL absoluteString] options:0 range:NSMakeRange(0, [[request.URL absoluteString] length])];
} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {
    NSData *data = [NSData dataWithContentsOfFile:[[NSBundle bundleForClass:[self class]] pathForResource:@"AdertisementInfo" ofType:@"json" inDirectory:nil]];
    return [OHHTTPStubsResponse responseWithData:data statusCode:200 headers:nil];
}];
}


 + (void)stubFetchADConfigSucceed{
[OHHTTPStubs stubRequestsPassingTest:^BOOL(NSURLRequest *request) {
    NSRegularExpression *re = [NSRegularExpression regularExpressionWithPattern:@"/test/v3/perzhi"
                                                                        options:0
                                                                          error:nil];
    return [re numberOfMatchesInString:[request.URL absoluteString] options:0 range:NSMakeRange(0, [[request.URL absoluteString] length])];
} withStubResponse:^OHHTTPStubsResponse *(NSURLRequest *request) {
    NSData *data = [NSData dataWithContentsOfFile:[[NSBundle bundleForClass:[self class]] pathForResource:@"ADConfig" ofType:@"json" inDirectory:nil]];
    NSDictionary *json = [NSJSONSerialization
                          JSONObjectWithData:data
                          options:kNilOptions
                          error:nil];
    NSLog(@"json:%@",json);
    return [OHHTTPStubsResponse responseWithData:data statusCode:200 headers:nil];
}];
}
</code></pre>

<p>（2）创建一个objective-c的.m文件，用spec语法进行创建</p>

<pre><code>  SpecBegin(MyBannerModel)
  describe(@"MyBannerModel", ^{
context(@"", ^{
    beforeAll(^{
        [ADModelHTTPStub stubFetchADInfoSucceed];
        [ADModelHTTPStub stubFetchADConfigSucceed];
    });        
    afterAll(^{
        [OHHTTPStubs removeAllStubs];
    });    
    it(@"", ^AsyncBlock{
        MyBannerModel *infoModel = [[MyBannerModel alloc] init];
        [[infoModel fetchSomeADInfoByID:@"2" withVersion:@"0.6.2"] subscribeNext:^(NSArray *infoArray) {
            expect(infoArray).notTo.beNil();
            expect([infoArray count]).to.equal(3);
            done(); 
        }];            
    });
    it(@"", ^AsyncBlock{            
        MyConfigModel *configModel = [[MyConfigModel alloc] init];
        [[configModel fetchWithApp:@"iphone"] subscribeNext:^(MTADConfig *config) {
            expect(config).to.beKindOf([MyADConfig class]);
            done();
        }]; 
    });    
});
 });
SpecEnd
</code></pre>

<h3>4、其他相关</h3>

<pre><code>（1）logit test与application test区别
   logit test类似于白盒测试，用于测试工程中较细节的逻辑，application test类似于黑盒测试，或者接口测试，用于测试直接与用户交互的接口（服务器接口返回的数据在客户端展示是否正常）
  logit test与application test的区别还表现在setUp方法上， logit test只需要在setUp方法中初始化一些测试数据，application test需要在setUp方法中获取主应用的AppDelegate,供test方法调用。这样是网上有人这么说的， 但是自己不太明白真正的原因，猜想是应用测试需要调用接口？

   网上说要注意对于会侵入主应用的test bundle，在使用过程中要十分注意，不要让单元测试的资源覆盖主应用资源，否则会造成诡异的bug，我猜想这个可能就是要使用mock stub 等测试框架来模拟数据的原因，而不是直接使用主应用返回的数据。

 (2) xcode现在也支持与ui操作相关的测试，可以参照网上别人的探索
 http://www.cocoachina.com/ios/20150702/12253.html

（3）RAC绑定相关测试的注意事项
  下面以一个登录页面文本输入框的绑定为例，摘录自网上实例。这里有一个关键点，emailTextField或passwordTextField必须调用sendActionsForControlEvents:UIControlEventEditingChanged方法，才能触发textField的text属性改变。

  技巧：要找到相应调用方法需要通过查看对应控件的RAC源码中将通知（相应方法）转化为信号的处理过程。
  SPEC_BEGIN(LoginViewControllerSpec)

 describe(@"LoginViewController", ^{
__block LoginViewController *controller;

beforeEach(^{
    controller = [UIViewController loadViewControllerWithIdentifierForMainStoryboard:@"LoginViewController"];
    [controller view];
});

afterEach(^{
    controller = nil;
});

describe(@"Email Text Field", ^{
    context(@"when touch text field", ^{
        it(@"should not be nil", ^{
            [[controller.emailTextField shouldNot] beNil];
        });
    });

    context(@"when text field's text is hello", ^{
        it(@"shoud euqal view model's email property", ^{
            controller.emailTextField.text = @"hello";
            [controller.emailTextField sendActionsForControlEvents:UIControlEventEditingChanged];
            [[controller.viewModel.email should] equal:@"hello"];
        });
    });
});

describe(@"Password Text Field", ^{
    context(@"when touch text field", ^{
        it(@"should not be nil", ^{
            [[controller.passwordTextField shouldNot] beNil];
        });
    });

    context(@"when text field' text is hello", ^{
        it(@"should equal view model's password property", ^{
            controller.passwordTextField.text = @"hello";
            [controller.passwordTextField sendActionsForControlEvents:UIControlEventEditingChanged];

            [[controller.viewModel.password should] equal:@"hello"];
        });
    });
});
});

 绑定的测试通过之后，可以进一步模拟绑定得到的数据，进行其他相关测试。

（4）写与MVVM框架相关的单元测试的方法
    model层：主要通过打桩测试网络请求返回的数据，通过订阅相应方法的signal返回的信号进行测试
    viewmodel层：主要执行相应commad，然后订阅command中被赋值的属性数据，进行测试
    viewcontroller层：对一些绑定操作等的测试。

 （5）写单测过程中遇到的问题和解决办法
  在测试vm层相关command执行后返回的结果时，通常做法是通过RACObserver来观察返回值，使用
   [RACObserve(viewModel, sectionCollectionResults) subscribeNext:.... 或者
   [RACObserve(viewModel.sectionCollectionResults, objectsCount).....
   是需要取决于你要测试的代码，如果是在执行command返回时初始化sectionCollectionResults并添加元素，第一个可以订阅到信号。否则好似订阅不到的。需要通过下面的方式。

   使用[RACObserve(viewModel.sectionCollectionResults, objectsCount).订阅时，又由于commad在返回结果时会对sectionCollectionResults先进行clearall操作。
</code></pre>

<h3>(5) 各个框架的api文档</h3>

<p><a href="https://github.com/specta/specta">https://github.com/specta/specta</a>
<a href="https://github.com/specta/expecta">https://github.com/specta/expecta</a>
<a href="http://ocmock.org/reference/">http://ocmock.org/reference/</a>
<a href="https://github.com/AliSoftware/OHHTTPStubs">https://github.com/AliSoftware/OHHTTPStubs</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/mvvmkuang-jia-xue-xi-shi-jian/">MVVM框架学习实践</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-20T17:54:08+08:00'><span class='date'>2015 年9 月20 日</span> <span class='time'>5:54 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>1、mvvm基本概念</h2>

<pre><code>   在MVC框架的基础之上，将view和view controller联系在一起作为一个整体，同时新建一个视图模型层view model，负责view和view controller这个整体与model层之间的通信。同时将原来ViewController中放置用户输入验证逻辑、视图显示逻辑、发起网络请求和其他各种各样的耗时操作放到 view model中。在MVVM框架的基础之上，再结合RAC响应式编程，通过在控制器层对模型层数据的绑定，来实现界面与模型层之间的数据交换。
</code></pre>

<h2>2、mvvm层次结构</h2>

<pre><code>     MVVM主要分为一下几层，
     model层：数据模型层
     view(view和view controller)层：显示自定义视图和和管理视图的控制器层
     view model层：连接model层和view层之间的桥梁，主要负责一些业务逻辑操作
</code></pre>

<h2>3、mvvm使用场景</h2>

<pre><code>（1）结合RAC简化自定义view与model层之间数据交互在控制器中使用RAC、RACObserver宏对view中要展示数据与view model层获取的model层数据进行绑定。
  使用RACCommad来响应界面的交互，具体步骤如下：
  第一步：在自定义view中定义一个command，在子view点击操作中执行这个command，excute：可以看看官网文档上它的用法

  第二步：在controlller中，把它与自定义view中的相应command进行绑定。在绑定的时候就实现这个commad的具体操作。

  第三步：也可以在controlller中定义这个commad属性。在属性的set方法中返回它的具体实现，最后不能忘记还要对这个commad与自定义view中的相应command进行绑定。

  第四步：commad的执行一般分以下几种状态：正在执行、执行失败、执行完（可以返回一个数据，但是一般通过修改某个与view进行绑定的数据之后，就可以自动通知view界面进行修改了，所有不返回数据也是可以的）

  （2）将UITableView上的数据源（实现&lt;UITableViewDataSource&gt;协议及其方法的类）分离出来，放到vm层。这样使得代码逻辑更清晰，且更有利于做单元测试。如果设置M层，还可以对代码做进一步的改进。
               实例代码如下所示：
</code></pre>

<p> VM层</p>

<pre><code>//声明一个block类型
typedef void (^TableViewCellConfigureBlock)(id cell, id item);
 //声明TableDataSource 类，实现UITableViewDataSource协议
@interface TableDataSource : NSObject &lt;UITableViewDataSource&gt;
 //定义一个实例化方法,设置数组、重用标识符，并调用相应block
- (instancetype)initWithItems:(NSArray *)anItems
           CellIdentifier:(NSString *)aCellIdentifier
       ConfigureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock;
 //根据indexPath返回item数组中的相应值
- (id)itemAtIndexPath:(NSIndexPath *)indexPath; 
@end



＃import “TableDataSource.h”
@interface TableDataSource ()
 //存放数据的数组
@property (nonatomic, strong) NSArray  *items;
 //重用标识符
@property (nonatomic, copy) NSString *cellIdentifier;
 //block对象
 @property (nonatomic, copy) TableViewCellConfigureBlock configureCellBlock;
 @end

 @implementation TableDataSource
 //自动生成get和set方法
 @synthesize items = _items;
 @synthesize cellIdentifier = _cellIdentifier;
 @synthesize configureCellBlock = _configureCellBlock;



 - (id)init {
return nil;
 }
- (instancetype)initWithItems:(NSArray *)anItems
           CellIdentifier:(NSString *)aCellIdentifier
       ConfigureCellBlock:(TableViewCellConfigureBlock)aConfigureCellBlock
 {
self = [super init];
if (self) {
    self.items              = anItems;
    self.cellIdentifier     = aCellIdentifier;
    self.configureCellBlock = [aConfigureCellBlock copy];
}
return self;
 }


- (id)itemAtIndexPath:(NSIndexPath *)indexPath {
return _items[(NSUInteger)indexPath.row];
}
</code></pre>

<p>   pragma mark - UITableViewDataSource</p>

<pre><code>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
return 1;
 }

 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
return [_items count];
 }

 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:_cellIdentifier];
id item = [self itemAtIndexPath:indexPath];
 if (!cell) {
     cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:_cellIdentifier];
 }
//回调block。这个block是传进来的，所有实际是执行外面的代码
self.configureCellBlock(cell, item);
return cell;
}

@end
</code></pre>

<p>V层</p>

<pre><code> #import "TableViewController.h"
 #import "TableDataSource.h"
 static NSString * const kCellIdentifier = @"Cell";
 @interface TableViewController ()//定义一个实现UITableViewDataSource协议的类的属性。用于给tableview设置数据源
 @property (strong, nonatomic) TableDataSource *dataSource;
 @end

 @implementation TableViewController
 //自动生成get和set方法
 @synthesize dataSource = _dataSource;
- (void)viewDidLoad
{
[super viewDidLoad];
TableViewCellConfigureBlock cellConfigureBlock = ^(UITableViewCell *cell, NSString *item) {
    cell.textLabel.text = item;
};
NSArray *stringsArray = @[@"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3", @"1", @"2", @"3"];
self.dataSource = [[TableDataSource alloc] initWithItems:stringsArray
                                          CellIdentifier:kCellIdentifier
                                      ConfigureCellBlock:cellConfigureBlock];
self.tableView.dataSource = _dataSource;
 }

@end
</code></pre>

<p>   （3）下面的代码将用户登录的验证代码分离出来，但是应该不是完全的mvvm的模式，因为还是通过block进行的回调？还要多些代码体会理解
              类似VM层</p>

<pre><code>＃import &lt;Foundation/Foundation.h&gt;
//定义返回值参数的block的类型
typedef void (^RWSignInResponse)(BOOL);
@interface RWDummySignInService : NSObject
//在该方法的实现中，对传入的用户名密码进行处理，然后给block传入参数，并调用block
//定义一个包含输入参数及返回值block参数的函数。函数的返回值通过block传递出去，调用这个函数，执行block，就可以对这个返回值进行处理了。
- (void)signInWithUsername:(NSString *)username password:(NSString *)password complete:(RWSignInResponse)completeBlock;
@end


 ＃import "RWDummySignInService.h"
  @implementation RWDummySignInService
 //具体实现，传入用户名和密码，调用block（设置block的参数，然后回调传入的blobk的实现代码，
 //block作为方法的参数，调用方法的时候一定要实现这个block，方法的实现是调用这个block

 - (void)signInWithUsername:(NSString *)username password:(NSString *)password complete:(RWSignInResponse)completeBlock {
double delayInSeconds = 2.0;
//设置执行线程之前的等待时间,将前面的double类型进行一个转换
dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
//执行线程，参数popTime：延迟时间。参数dispatch_get_main_queue()：获取运行在主线程的Main queue
dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
    BOOL success = [username isEqualToString:@"user"] &amp;&amp; [password isEqualToString:@"password"];
    completeBlock(success);
});
 }
@end
</code></pre>

<p>V层</p>

<pre><code> $import &lt;UIKit/UIKit.h&gt;
 @interface RWViewController : UIViewController
 @end


  #import "RWViewController.h"
  #import "RWDummySignInService.h"
  #import "ReactiveCocoa/ReactiveCocoa.h"
  @interface RWViewController ()
  @property (weak, nonatomic) IBOutlet UITextField *usernameTextField;
  @property (weak, nonatomic) IBOutlet UITextField *passwordTextField;
  @property (weak, nonatomic) IBOutlet UIButton *signInButton;
 @property (weak, nonatomic) IBOutlet UILabel *signInFailureText;
 @property (strong, nonatomic) RWDummySignInService *signInService; //处理用户点击事件的接口（信号）

 @end


 @implementation RWViewController

 - (void)viewDidLoad {
  [super viewDidLoad];
 //下面是创建（有效状态信号），理解其含义的代码
//我们可以使用map操作转换我们想要的数据，只需要它是一个对象，
RACSignal *validUsernameSignal = [self.usernameTextField.rac_textSignal map:^id(NSString *text) {
    return @(text.length &gt; 3);
  ]);
}];
RACSignal *validPasswordSignal = [self.passwordTextField.rac_textSignal map:^id(NSString *text) {
    return @(text.length &gt; 3);
}];
</code></pre>

<p> //下面ReactiveCocoa定义的一些宏，感觉这个宏是把函数要返回的对象的属性都声明了，直接return就行了</p>

<pre><code>RAC(self.passwordTextField, backgroundColor) = [validPasswordSignal map:^id(NSNumber *passwordValid){
    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}];

RAC(self.usernameTextField, backgroundColor) = [validUsernameSignal map:^id(NSNumber *usernameValid) {
    return [usernameValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}];
</code></pre>

<p>  //一开始将下面的combinelatest的参数直接用text，一致报找不到方法的错误，然后马上跟断点进行调试。发现应该要转换成信号。才可以</p>

<pre><code>RAC(self.signInButton, enabled) = [RACSignal combineLatest:@[self.usernameTextField.rac_textSignal, self.passwordTextField.rac_textSignal] reduce:^id(NSString *name, NSString *password){
    return @(name.length &gt; 3 &amp;&amp; password.length&gt;3);
}];
</code></pre>

<p>//正确的，将按钮点击事件映射到一个登录信号，但同时通过将事件从内部信号发送到外部信号，使这个过程变得扁平化。</p>

<pre><code>[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) {
    return [self signInSignal];
}] subscribeNext:^(NSNumber *signedIn) {
    BOOL success = [signedIn boolValue];
    self.signInFailureText.hidden = YES;
    if (success) {
        [self performSegueWithIdentifier:@"signInSuccess" sender:self];
    }
    NSLog(@"sign in result :%@",signedIn);

}];


 //创建处理点击事件的接口类对象
  self.signInService = [RWDummySignInService new];
 // 初始化提示框为隐藏
  self.signInFailureText.hidden = YES;
 }

- (RACSignal *)signInSignal{
return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [self.signInService signInWithUsername:self.usernameTextField.text password:self.passwordTextField.text complete:^(BOOL success) {
        [subscriber sendNext:@(success)];
        [subscriber sendCompleted];
    }];
    return nil;
}];
 }
 @end
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/ocnei-cun-guan-li/">OC内存管理</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-11T16:09:37+08:00'><span class='date'>2015 年9 月11 日</span> <span class='time'>4:09 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、RunTime（运行时）概念理解</p>

<p>   （1）函数调用方式</p>

<pre><code>      OC的函数调用即通过在对象上调用方法，也称之为“传递消息”，相对于C语言函数调用，使用静态绑定，即在编译期就决定运行时所应调用的函数，OC则是通过动态绑定的方式，对所要调用的函数在运行期才能确定，即对象收到消息之后，究竟该调用哪个方法完全由运行期决定，并且可以在程序运行时改变，是一门真正的动态语言。
</code></pre>

<p>   （2）函数调用（传递消息）过程 1</p>

<pre><code>       函数调用过程即给对象发送消息的处理过程，以id returnValue = [someObject measageName:pameter] 消息为例：
       编译期，编译器看到这行代码，会将其转换为一条标准的C语言函数调用，id returnValue = objc_msgSend(someObject, @selector(messageName:),  parameter);  如果在编译期向类发送了其无法解读的消息也不会报错，因为运行时可以继续向类中添加方法。

       运行期，即动态消息派发系统执行过程，objc_msgSend函数会首先根据接收者（someObject）和选择子（measageName）的类型在接收者所属的类中搜寻它的方法列表，这个方法列表其实是类里面的一张表格，表格是一个存放健值对的列表，健用选择子的名字表示，值即选择子对应方法的函数指针，因为OC对象的每个方法都可以视为如下简单的C函数，&lt;return_type&gt; Class_selector(id self, SEL _cmd, ...)，这也是为什么后面找到相应匹配的方法后，能够跳转到相应实现代码的原因。
        如果在方法列表中找到与选择子名称相符的方法，就跳转到相应方法的实现代码，如果找不到，就沿着继承体系继续向上查找，若找到合适的方法就会再跳转到该方法实现代码，如果最终还是没找到相符合的代码，执行消息转发。即后面将要介绍的消息转发过程。《在这个过程中，objc_msgSend会将匹配结果缓存到快速映射表，这样后面执行相同的查找速度更快，尽管没有静态绑定的函数调用那么迅速，但是也不会慢很多了》
       下面的几个函数，与objc_msgSend函数类似，它们主要用于处理一些边界情况，可以了解一下
        objc_msgSend_stret 待发送的消息要返回结构体   objc_msgSend_fpret 待发送的消息要返回浮点数  objc_msgSendSuper待发送的消息要给超类发消息。
</code></pre>

<p>   （3）函数调用（消息转发）过程 2</p>

<pre><code>      经过上面传递消息过程还是没有找到匹配的方法之后，就会启动下面的消息转发过程。消息转发又分为动态方法解析、备援接受者、完整的消息转发三个步骤。
     动态方法解析：类的接受者，看是否能动态添加方法，以处理当前无法解读的选择子，首先要在所属类中重写下面的类方法，＋(BOOL) resolveInstanceMethod ( SEL )，前面是为了处理未知的实例方法，如果是处理未知的类方法，重写 ＋(BOOL) resolveClassMethod ( SEL )，selector 参数,即未知的选择子，在这里有机会新增处理此选择子的方法，若方法的实现代码已经写好，运行的时候就会动态插入到类里面。书本上coredata的dynamic属性即通过上面的方式实现。

     备援接受者：请接受者看看有没有其他对象能处理这条消息，这一步进行处理的相应方法为 － (id) forwardingTargetForSelector: (SEL) selector; 方法参数即代码未知选择子，注意：我们无法操作经由这一步转发的消息，要通过接受者自己去找备援对象，若找到则返回，找不到返回nil。 

    完整消息转发：修改消息的内容，即创建NSInvocation对象，把未能处理的消息的选择子，目标及参数封装到这个对象中，然后触发NSInvocation对象，把消息指派给目标对象，通过重写下列方法来转发消息。－ （void) forwardInvocation:(NSInvocation *) invocation。此方法默认实现，即改变调用目标，使消息在新目标上可以调用，这样与备援接受者实现的方法等效，只是在发送给备援接受者之前可以修改消息内容。
</code></pre>

<p>2、method swizzling的理解和用法</p>

<pre><code>    (1) Method Swizzling基本概念        
        通过前面对OC运行时的理解，允许我们修改selector(method name)到implementation(the method code itself)的映射。网上说，利用这个特性，我们可以"修补"那些没有源码的方法，如（AppKit，FoundationKit，或第三方的库等）。给这些方法基础上，增加新的操作，等和category不同的是，category如果定义了一个原来相同的方法，那么会直接覆盖原来的方法。Method Swizzling让你可以在替代原来的方法的同时可以调用原来的方法，并且为这个方法增加一些新的功能，记录日志等等，有点像subclassing。
    (2) Method Swizzling原理
    在前面已经讲到，在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。

  每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。
  selectorA --&gt; IMPa    selectorB --&gt; IMPb    selectorC --&gt;IMPc ....

 要实现互换两个函数的操作，首先要利用下面的两个函数：
 void method_exchangeImplementation(Method m1, Method m2)   //交换参数中传入的两个方法实现，方法实现可通过下面的函数获得
 Method class_geInstanceMethod (Class aClass, SEL aSelector)   //根据给定的选择从类中取出与之相关的方法的实现
以交换selectorA和selectorB两个方法的实现为例，交换后的指针指向为，selectorA --&gt; IMPb  selectorB --&gt;  IMPa

 (3) Method Swizzling实例代码
 以在NSString的一个分类中添加一个新的方法myLowercaseString ,与NSString已经存在的lowercaseString方法的交换为例，首先在分类中定义如下方法：

  @interface NSString (myAdditions)
 - (NSString *)myLowercaseString;
 @end

 @implementation NSString (myAdditions)
 - (NSString *)myLowercaseString {
NSString *lowercase = [self myLowercaseString];
NSLog(@"输出结果为:%@ =&gt; %@", self, lowercase);
return lowercase;
}
 @end

 // 通过下面代码来交换上面两个方法
Method originMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
 Method swappedMethod = class_getInstanceMethod([NSString class], @selector(myLowercaseString));
 method_exchangeImplementations(originMethod, swappedMethod);
 //最后在NSString上调用lowercaseString方法，会输出NSLog的打印语句，输出结果为:
 NSString *string = @"THIS IS THE STRING";
 NSString *lowercaseString = [string lowercaseString];

 //实际上，交换方法后，lowercaseString调用的是myLowercaseString的具体实现，而myLowercaseString里面又调用它自己指向的lowercaseString方法的实现，从而得到上面的输出结果
</code></pre>

<p>第三部分、懒加载</p>

<p>懒加载——也称为延迟加载，即在需要的时候才加载（效率低，占用内存小）。
注意：如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化</p>

<p>使用懒加载的好处：
（1）不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强
（2）每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合
具体实现：重写相关属性的get方法，在这个方法中alloc init该属性，如果是ui控件，在这里创建后添加到父控件上。</p>

<p>有一个问题：在ARC下使用懒加载，不在当前可见范围内的控件会不会做release处理，就像UITabBarController不在当前显示窗口上的viewcontroller就应该释放。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/runloopxue-xi-diao-yan/">Runloop学习调研</a>
      </li>
    
      <li class="post">
        <a href="/blog/git-xue-xi-bi-ji/">Git 学习笔记</a>
      </li>
    
      <li class="post">
        <a href="/blog/nsurl-loading-system/">NSURL Loading System</a>
      </li>
    
      <li class="post">
        <a href="/blog/reactive-cocoaxue-xi-bi-ji/">Reactive Cocoa学习笔记</a>
      </li>
    
      <li class="post">
        <a href="/blog/swift-xue-xi-zong-jie/">Swift 学习总结</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - 梁芳 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
