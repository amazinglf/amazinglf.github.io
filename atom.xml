<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://amazinglf.github.io/atom.xml" rel="self"/>
  <link href="http://amazinglf.github.io/"/>
  <updated>2016-04-15T13:08:20+08:00</updated>
  <id>http://amazinglf.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift 学习总结]]></title>
    <link href="http://amazinglf.github.io/blog/2016/01/01/swift-xue-xi-zong-jie/"/>
    <updated>2016-01-01T14:33:03+08:00</updated>
    <id>http://amazinglf.github.io/blog/2016/01/01/swift-xue-xi-zong-jie</id>
    <content type="html"><![CDATA[<p>Swift学习之基础部分
常量和变量,主要掌握根据它们使用的场景，对不会变化的值使用常量，对不断变化的值使用变量。</p>

<p>注释：单行注释使用//，多行注释使用/<em>  </em>/，对于多行注释还可以使用嵌套。</p>

<p>分号：Swift中可以省略分号，如果在同一行有多条语句，需要用分号隔开。</p>

<p>整数：Int UInt 可以通过它的最大值、最小值属性获取它表示的范围。</p>

<p>浮点数：带有小数点的数据类型，Float Double。</p>

<p>类型安全和类型推断：Swift会在编译的时候对代码进行类型检查，把不匹配的类型标记为错误。如果给变量或常量赋了初始值的时候，可以不申明类型，由系统进行类型推断。</p>

<p>1、基础数据类型（本质都是通过结构体或枚举类型定义的）
  常量定义 let  i ＝ 10，常量一般必须要赋一个初值
  变量定义 var j : Int ，变量如果指定类型可以不赋初值,如果没有指定类型必须赋初始值
  它们的共同特点就是可以不指定值的类型。如果没有指定类型编译器会根据你赋的值进行类型推断。
  总结：Swift支持隐式类型推断，不支持隐式类型转换（把某种类型的值赋值给另一种类型的值）。</p>

<p>2、swift新增的数据类型
  元组（tuples)
  可选值
  隐式解析可选</p>

<p>3、字符串数据类型
  首先理解字符串存储由来，我们都知道计算机只能识别0101的数字，那一些非数值类型的字符是如何存储的呢，首先需要制定一些统一的标准，将符号转化为数字，由此出现针对英文字符的ASCII编码，但是全世界除了英文，还要中文，俄文等等其他语言，ASCII编码已经不能满足我们的需求，因此出现一个支持全世界各种语言的国际标准Unicode标准，而swift就是支持Unicode标准的一门语言，并且它的变量名也是支持中文的。</p>

<p>4、运算符
   与其他语言的区别，一个赋值运算符整体构成的表达式不代表一个值，不能进行连续赋值a＝b＝1，并且赋值运算符也不能出现在if判断语句中了，如果出现就会报错，这样也能避免我们把==写成＝，而不报错的情况出现。
   还有另外一个区别，swift新增了一种区间运算符，定义如下：0&hellip;5 表示0，1，2，3，4，5。0&hellip;&lt;5 表示0，1，2，3，4。有一个需要注意左右区间不能用小数，否则会出现一直循环。</p>

<p>5、集合数据类型
  数组：相同类型的数据在数组中连续排列，因为是有序，元素检索速度非常快（c语言数组定义）。Swift数组的定义与此类似，还是有很多差别。定义如下：var array1 : Array<Int> = ［1,2,3,4］,因为数组中元素类型定义为范型，我们可以定义为任意一种类型。 并且Swift的数组中可以放置任意类型的数据。通过设置它的类型为Any，如下：var array1 : Array<Any> = ［“hello”,2,3,4］，至于它为什么能存储不同数据类型，可以从数组的结构体定义以及存储上去找原因。并且Swift允许在结构体中声明方法，更符合面向对象思想。
  数组操作：读数据，通过数组下标的方式，同样也要注意数组越界的问题。修改数据，前提数组是变量，可以通过append、insert等向数组中添加一个元素，或者以直接赋值的方式修改数组中某个元素，以及通过removeLast、removeAtIndex删除数组中的某个元素。
  slice：一种与数组非常相似的集合类型，定义也差不多一样，和数组可以进行相互转换，如：Slice sli = array1[0&hellip;5] 通过区间运算符或者使用Slice的结构体方法定义 Slice sli = Slice(array1)，不能直接赋值
 range：用来存放区间表达式的值，它的本质是结构体，它也支持泛型（即任意类型，但也必须遵守forwardindex协议），var range : Range<int> = 0&hellip;3 或者通过构造方法定义 var range2 : Range<int> = Range(start:0, end:3)，需要注意的是这里表示0，1，2，不包括3。而前面的定义包括3.
 数组批量操作，前面讲的slice、range都是为数组的批量操作做准备的。</p>

<p>  (1) 可以将range指定范围内的数替换成任意其他个范围内的数，var array1 = ［1,2,3,4］array1[0&hellip;1] = ［8,7,8,9]。最后得到的array1为:［8,7,8,9,3,4]。或者使用函数array1.replaceRange(Range(start:0, end:2), With:[8,7,8,9]).，实现和前面一样的结构
  (2) 数组还可以通过复合的赋值运算符往数组中添加元素、数组、slice等，array1+=9 等价于 array1.append(9)，array1+＝[1,2,3]，array1+=slice，array1+=array2[0&hellip;5]
  数组遍历，第一种for in 快速枚举，第二种通过元组进行遍历
for elem in array1{
  println(elem)
}
 for  (index, value) in enumerate(array1){
  println(&ldquo;index:(index) = (value)&rdquo;);    //其中(index)类似于对字符串中格式化占位符的处理
}</p>

<p>6、字典数据类型
基本概念，存放无序的数据，因此它的遍历需通过检索数据关键字实现，它类似于数据结构中hash函数和hash表的概念，首先根据key和hash函数计算出一个地址，addr = hash(key)，然后从hashtable中根据这个地址获取到key对应的值，value ＝ hashtable(addr)。所以key首先是必须可hash的，在swift中可hash，即需要遵守一个协议，一般的基本数据类型string、int、float等都遵守相应协议，因此，一个字典中它的key值也可以是多样的。 如：var dict ＝ ［”1“:a，2:b]
字典操作，读：println(dict[&ldquo;1&rdquo;])  写：dict[2] = 8 修改：dict.updatevalue(9,forkey(&ldquo;1&rdquo;))。需要注意修改操作返回的是一个可选值，如果key存在，会替换key对应的值，并且返回key对应的之前的值，如果key不存在，会向字典中增加一个这个不存在key所对应的值，相当于往字典中添加了一个新的值，并且返回nil。删除：dict.removevalueforkey(&ldquo;1&rdquo;)，同样，如果存在这个key，就删除相应key对应的值，同时返回旧的value值，如果不存在这个key旧不做任何操作，返回nil。字典遍历，即类似元组遍历，同时也可以遍历所有key，或者所有value
if let orignal = dict.updatevalue(9,forkey(&ldquo;1&rdquo;)){
println(&ldquo;new:(dict["1&rdquo;])&ldquo;);
println(orignal);
}
if let orignal = dict.removevalueforkey("1&rdquo;){
println(original)
}
for (key,value) in dict{
println(&ldquo;(key):(value)&rdquo;)
}
for key in dict.keys{
print(key)
}
for value in dict.values{
println(value)
}</p>

<p>7、swift中语句的基本用法
if语句，以及if中多分支执行语句，我们知道程序不可能只有一种执行顺序，因为实际生活中往往存在多种选择或者循环问题，下面从程序指令执行过程的角度考虑：
顺序指令：比较好理解，选择指令：有些指令被执行，有些指令不会执行，循环指令：某些指令会循环不断的被执行。将这三种指令相结合，可以解决我们实际生活中的绝大部分问题。
其中if else、while、for in、break、continue语句的使用与OC语言都非常相似，要特别注意的是switch语句与其他语言的switch语句有一些差别，主要区别为三点，（1）最后必须加default （2）可以去掉break了，oc中如果case语句后面不加break，会造成switch贯穿执行，即匹配到某一个case选项后，后面的所以case的语句都会被执行，而在switch中，不需要显示添加break，它匹配到case后，会自动退出。（3）case后面可以添加多个匹配条件，如case “a",&ldquo;b&rdquo; 类似于或，只要有一个满足要求即可。（4）因此，switch支持广义匹配，匹配类型可以是整形、区间运算符、元祖、通配符（如<em>，表示任意一个字符），实例如下。（5）switch具有值匹配模式特性，在第三个例子中，case中的let x let y表示：x y可取任意值，一旦有值，会把它绑定到x y中，赋给x y，x y页可以为常量，［let x， let y］与［let（x，y）］两者的写法是等价的。在case匹配语句使用值绑定的情况下，可以在后面加上where条件，加上值绑定模式的匹配条件。
let x = 1000 ｛
 case 1&hellip;9 :
   println(&ldquo;个位数&rdquo;);
 case 10&hellip;49:
  println(&ldquo;十位数&rdquo;)
 default:
  println(&ldquo;不符合&rdquo;)
｝
let point = (10,10)
switch point ｛
  case (0,0) :
   println(&ldquo;坐标原点&rdquo;)
 case (1&hellip;10, 1&hellip;10) :
   println(&ldquo;x,y坐标位于1-10之间&rdquo;)
  case(</em>, 0) : <br/>
   println(&ldquo;点在x轴&rdquo;)
  default :
   println(&ldquo;其他&rdquo;)
｝
swith point ｛
 case (let x ,10)
  println(x)
case let(x, y)
  println(&ldquo;(x):(y)“）
case let x, let y
  println(&rdquo;(x):(y)“）
case let (x, y) where x == -y
  println(&ldquo;(x):(y)“）
//返回两个顶点的长和宽
let po = (double, double) = (0,0)
let p1 = (double, double) = (8,8)
fun getlengthandwidth(p0:(double,double), p1(double,double)) -> (length:double, width:double) ｛
   return (abs(p0.0-p1.0), abs(p0.1-p1.1))
}
let w = getlengthandwidth(p0, p1).width
let h = getlengthandwidth(p0, p1).length
//这里要通过名称访问元祖的某个元素，要定义返回值元组中每个元素的名称</p>

<p>8、函数的相关概念
定义：完成某个特定功能的代码块，该代码块可重复使用。
语法：func 函数名(参数名:参数类型,参数名:参数类型,&hellip;) -> 函数返回值类型 ｛      //函数实现部分      ｝   <br/>
调用语法：函数名（实际参数&hellip;）   函数名遵循驼峰命名法 ，可以有多个参数，多个返回值，也可以没有参数没有返回值（没有返回值时，可以不写->,或者写-> void）。实例代码如上面第四个例子所示，
内部参数与外部参数概念：因为函数的定义实现与函数的调用是分开的，因此当我们看到某个函数调用的代码或者想要调用某个函数时，希望通过参数名就可以了解传递参数的含义，而不用去看函数的定义和实现。因此swift提供了一个外部参数，我们在调用函数的时候可以显示对这个外部参数赋值，这样函数的参数信息一目了然。类似于oc中通过方法名帮助我们理解参数含义，swift中则通过外部参数帮助我们理解函数传入参数的含义，实例代码如8-1所示，注意：函数实现部分，只能使用内部参数。如果内部参数和外部参数想使用同一个名字，即一个参数即表示内部参数又表示外部参数，可在参数名前面加上＃，进行标识
8-1
8-2
8-3</p>

<p>func divisionoperation(dividend a:double, divisor b:double) -> double ｛
  return a/b
}
let res = divisionoperation(dividend:3.5, divisor:1.2)
func joinstring(s1:string, tostring s2:string, joiner s3:string = &ldquo;#&rdquo;) -> string ｛
  return s1+s2+s3
}
let str = joinstring(&ldquo;hello&rdquo;, tostring:&ldquo;world&rdquo;)
func swap(a:int, b:int){
let t = a
a = b //这里会报错
b = t
}</p>

<p>   函数默认值参数概念：即对函数中的某个参数指定默认值，相应在调用时可以不给这个默认值参数赋值，有一个需要注意的：当带有缺省值或默认值的这样一个参数，如果只有一个参数名，内部参数名将作为外部参数名使用，因为调用函数，修改其参数默认值，必须使用其外部参数名，否则报错，因此，在函数默认值参数的定义中，如果只定义了内部参数名，没有定义外部参数名，编译器会把默认值参数的内部参数名当作外部参数名使用，这属于编译器做的一个优化，实例代码如8-2所示，注意：对比c++中默认参数必须写在函数参数列表最尾部，不能移到参数列表前面，但是swift中现在是可以的，即可以出现在参数列表的任一位置。
    常量参数与变量参数概念：默认函数的参数是常量类型，即只可以读，不可以写或者进行修改操作，如图8-3的使用，编译器会报错，我们可以把它定义为var类型，就可以修改了inout参数的使用：主要用在输入输出函数中，首先看8-4的代码,调用 swap(x,y)之后，最后的输出结果x还是10，y还是28，我们一般会认为x y值应该变化，其实并没有，它实际执行是将10赋值给a，19赋值给b，实际只修改了a b，没有修改x y，在c语言中也同样存在这样的问题，c语言的处理方式是可以 传递x y变量的地址，相应在swap函数中申明a b为指针。但是swift中没有指针，因此引入了一个inout关键字，通过这个关键字修饰参数。改进后的代码如8-5所示：注意：调用swap函数使用&amp;符号不是c语言中取地址的含义，而是将x y变量赋值给函数a b参数。总结：如果我们希望一个函数能修改外部的变量，首先在函数定义时需把参数定义为inout，输入输出参数类型，其次传递实参时需在变量前面加一个&amp;的形式传递过去，等价于a是x的引用，b是y的引用，传递的时候是把x y整个变量都传递过去，而不只是传递变量对应的值10 28，通过&amp;x &amp;y与inout a inout b的配合，最终达到修改函数传递参数的目的。注意：符号&amp;后面不能直接跟一个具体值，需要传一个变量名。
8-4
8-5
8-6
8-7
8-8
func swap(var a : int, var b : int){
let t = a
a = b
b =t }</p>

<p>var x = 10
var y =  28
swap(x,y)
 func swap(inout a : int, inout b : int){
let t = a
a = b
b =t }</p>

<p>var x = 10
var y =  28
swap(&amp;x,&amp;y)
func add (array : [int] -> int ｛
var sun = 0
for i in array ｛
 sum +=i
}
println(add([1,2,3,4,5]))
for array(array : int&hellip;) -> int ｛
var sum = 0
for i in array ｛
 sum += i
｝
println(add(2,3,4))
fun add (a:int, b:int) -> int ｛
return a+b
｝
fun sub (a:int, b:int) -> int ｛
return a-b
}
     变参参数，即参数个数可以是不确定的，要实现变参参数，我们首先想到的可能是通过数组的形式实现，如8-6实例代码所示，在swift中对变参参数进行了定义，语法格式为，参数名：参数类型&hellip;  ,只需要修改变量类型，即在参数个数不确定，但是参数类型都是一致的情况下可以这样使用，即把它当作一个数组（集合），并且 在调用时不用传数组，而是像调用函数一样，传递任意个相应类型的参数，如8-7所示，函数实现不变，并且在调用函数时做一些修改即可。注意：变参函数中变参必须放在参数列表最后面。
函数类型：（参数、返回值类型）类型相同的函数定义如下：函数参数类型以及返回值类型都一样只是实现不一样。如8-8所示，可以将上面的两个函数抽象出公共的函数类型（int, int) -> (int)，可以对这个函数类型做如下的一些定义。
     定义一个函数类型常量或变量：var calfunc: (int, int) -> int = add，这样非常类似c语言中函数指针以及oc中的block，申明这样一个变量有一个好处即可以对它重新赋值，calfunc = sub println(calfunc(3,5)，此时得到是sub函数计算的结果。因为一个函数类型的变量非常灵活，它可以指向相同类型的其他函数，可以达到c语言中函数指针及oc中block一样的功能。
函数类型作为一个参数，如8-9所示，将其关联。
8-9
8-10
9-1
9-2</p>

<p>func subcalfunc(a:int, b:int, #op:(int, int) -> int) ｛
return op(a, b)
}
println(subcalfunc(20.35,op:sub)
func max(a: int, b:int) -> int ｛
return a>b?a:b
｝
func min(a:int, b:int) -> int ｛
return a>b?b:a
｝
func choosefunc(#getmax:bool ) -> (int, int) -> (int)｛
return getmax?max:min
｝
var myfunc:(int, int) -> (int) = choosefunc(getmax:true)
println(myfunc(2,9))
func funcname(参数) -> 返回值类型 ｛
执行语句
｝
｛ （参数) -> 返回值类型 in
执行语句
｝
let sayhello:() -> void = ｛
println(&ldquo;hello word&rdquo;)
}  //无参闭包，() -> void可以不写
sayhello()
let add:(int, int) -> (int) = ｛
(a:int , b:int) -> int in
return a+b
}   //有参闭包，
println(add(3,5))</p>

<p>函数返回一个函数类型的返回值：当根据输入参数判断执行哪一个函数时使用，如8-10所示</p>

<p>9、闭包的基本概念
   闭包：从函数的定义来理解，完成某个特定功能的代码块，在swift中可以理解为闭包是一个更轻量级的函数（自包含的函数代码块），可以把函数分为三大类（1）全局函数（有名函数）。（2）闭包表达式（匿名），能捕获上下文中的常量或者变量，牵涉到内存管理，值捕获。(3)嵌套函数。</p>

<p>   闭包表达式的定义、申明和使用，与函数的区别，闭包没有函数名，但是它还是由参数类型和返回值类型构成，并且参数类型和返回值类型是写在大括号里面的，并且还有注意加一个关键字in，如果没有参数和返回值可以不加in，如9-1所示，上面是函数定义，下面是闭包定义。理解闭包表达式它实际也是有类型的， 在swift中很多都可以称之为一个类型，而类型又可以定义一些常量或变量。如9-2所示。上面的用法只属于非典型性用法，因为这些用法跟函数的使用还没有很多区别。</p>

<p>   闭包表达式的回调用法：即闭包比较典型的用法，下面9-3是一个冒泡排序的实例代码，对它进行改造，将array[j] > array[j+1]的比较通过闭包实现，假设这个比较需要处理比较多的内容，得到9-4所示代码，在9-4的bubbleSort2(&amp;array, intCmp)方法中，还可以把intCmp方法的实现代码直接移过来，不定义为变量。如果要修改比较策略，譬如字符串比较，数字最低位比较，可以只修改闭包函数。类似于block回调，我们可以定义多种block函数的实现，调用bubblesort只需要告诉它一个排序数据以及排序策略。相比于函数来说，闭包可以省略函数名，直接函数实现。通过闭包、block实现多种变化的功能，我们可以传递闭包表达式的多种不同实现，至于闭包表达式何时被调用，是由外层的函数决定的。
9-3
9-4
9-5
9-6
func showArray(array:[Int]){
    for x in array{
        print(&ldquo;(x)&rdquo;)
    }
    print(&ldquo;&rdquo;)
}</p>

<p>func bubbleSort(inout array:[Int]){
    let cnt:Int = array.count
    for var i = 1; i &lt; cnt ; i++ {
        for var j = 0; j &lt; cnt - i; j++ {
            if (array[j] > array[j+1]){
                let t = array[j]
                array[j] = array[j+1]
                array[j+1] = t
            }
        }</p>

<pre><code>}
</code></pre>

<p>}</p>

<p>var array = [6,5,9,3,5,2,10]
showArray(array)
bubbleSort(&amp;array)
showArray(array)
let intCmp = { (a:Int,b:Int) -> Int in
    if a > b {
        return -1
    } else if a &lt; b {
        return 1
    } else{
        return 0
    }
}</p>

<p>func bubbleSort2(inout array:[Int]){
    let cnt:Int = array.count
    for var i = 1; i &lt; cnt ; i++ {
        for var j = 0; j &lt; cnt - i; j++ {
            if (intCmp(array[j], array[j+1]) == -1){
                let t = array[j]
                array[j] = array[j+1]
                array[j+1] = t
            }
        }
    } }
showArray(array)
bubbleSort(&amp;array)
bubbleSort2(&amp;array, intCmp)
showArray(array)</p>

<p>bubbleSort2(&amp;array, {
    (a,b) in
    if a > b {
        return -1
    } else if a &lt; b {
        return 1
    } else{
        return 0
    }
})</p>

<p>bubbleSort2(&amp;array, {
    if $0 > $1 {
        return -1
    } else if $0 &lt; $1 {
        return 1
    } else{
        return 0
    }
})
sort($array,{
    return $0 &lt; $1
})
sort($array,{
  $0 &lt; $1
})
9-6-1
func bubbleSortFunc(inout array: [Int]){
    let cnt = array.count
    func swapValue(inout a:Int, inout b:Int){
        let t = a
        a = b
        b = c
    }
    &hellip;.
}
9-6-2
func getIntFunc(inc :Int) -> (Int) -> (Int){
    func incFunc(v: Int) -> Int{
        return inc + v
    }
    return incFunc
}
 9-6-3
let incFunc1 = getIntFunc(12)
print(incFunc1(15))
func getIncFuc(inc : Int) -> (Int) -> (Int){
    var mt = 20
    func incFunc2(v:Int) -> Int{
        mt++
        return inc + v + mt }
    return incFunc2
}</p>

<p>   闭包表达式的语法优化：为什么要优化，如何优化，借用swift强大的类型推断功能，实现闭包表达式类型优化，  （1）在函数中传递闭包表达式时省略类型，前提是函数申明中包含了闭包类型时，可以根据上下文推断，省略闭包参数类型及返回值类型。如9-5所示，（2）进一步优化，参数都可以省略，而是使用$0 $1来代替，如9-5下面所示</p>

<p>   尾随闭包：由于闭包表达式主要用于函数回调，在函数调用时，为了表达更清楚，书写更方便，应该将闭包作为函数最后一个参数，即尾随闭包。当闭包的执行语句，只有单个return表达式的情况下，可以简写去掉return，如9-5下面的代码所示。</p>

<p>   嵌套函数：在函数内部申明一个函数，并且这个内部函数只能在内部使用，即它的作用域是在内部函数左右开始，往下到它所在函数结束的位置，同时函数通过闭包捕获上下文的值也属于嵌套函数。如9-6所示，嵌套函数仅仅为它所在的函数服务，所以有一个优点就是可以让程序更直观更清楚。</p>

<p>   闭包捕获值定义：嵌套／内部函数可以引用不是它自己而是它所在外部函数申明的变量或常量，因此我们需要研究它捕获的原则，捕获的行为。在9-6-2的实例代码中，定义了一个嵌套函数，我们知道在函数内部申明的局部变量它的作用域和生命周期只在调用函数的时候有效，函数调用结束就不生效了，但是在上面这种情况下，inc被返回的嵌套函数保留了，我们可以暂时理解为一个副本，这个过程可理解为一个上下文的捕获。从内存管理和函数调用栈的角度考虑，一般认为inc随着函数getIntFunc的调用结束已经没有了，但是嵌套函数中使用了inc局部变量，我们就称之为值捕获，从9-6-3的例子中，会发现每次调用这个函数，返回值都会加1，说明嵌套函数捕获mt后，相当于拷贝了mt的一个副本，会记录mt上一次的值，我们可以理解为mt相当于incFuc的一个全局变量，我猜想如果mt是self，不做保护措施，就会出现循环引用啦。</p>

<p>   泛型：可以创建泛型的函数或者类型，之前对泛型的了解只停留在它的使用，对于如何自己去自定义一个泛型没有想过，看了文档上的例子也还不是太理解，后面还要多看看。以
func swapTwoValues<T>(inout a: T, inout b: T) {} 这个函数为例,通过<T> 占位类型名 同时指定函数参数的类型，在调用的时候直接传入一个任意类型即可。如果需要传入多个占位类型，可以用逗号隔开，进行如下表示 &lt;T,T>。数组是非常典型的泛型函数，它支持任意类型，现在如果自定义一个特定的数组：栈，就需要使用泛型函数了。</p>

<p>   协议和扩展：主要使用关键字protocol和extension来进行定义，它的使用和oc语言差不多（在语法定义上有一些差别，并且swift继承某个类和使用协议的语法是一样的在 : 后面，感觉这样不是很好，只是推荐把父类写在前面），可以将协议名作为一种命名类型来使用的做法还不是很理解（现在理解了，可以把协议类型作为函数参数类型、返回值类型等用法，充分发挥协议的优势，可以灵活的创建和传递同一个方法的不同实现），文档上的例子也标注了这样使用的注意事项。为什么swift的协议中要申明属性呢，与以前只申明方法相比，申明属性有什么好处呢？通常理解实现了协议的类型，该类型中必须拥有协议中相应的属性和方法（即协议只关心必须要有某些属性和方法，不关心属性和方法的具体值和具体实现）。注意：在协议中使用class关键字申明的类属性和类方法，当枚举和结构体实现这个协议时，需要使用static关键字。且协议中的方法不支持默认参数值。</p>

<p>   理解扩展的使用场景：在无法修改源代码，或者修改已有类不可行的情况下，需要对已有的类、结构体、枚举、协议等进行扩展。也可以对协议扩展以及补充某个类型为协议类型。</p>

<p>   枚举和机构体：枚举与其他语言的一个区别是它可以定义方法，并且它的语法也有了一些变化。文档上说结构体和类的一个最大区别是结构体是传值，类是传引用，这个概念跟我之前的理解好像有偏差， 还要多看看。</p>

<p>   对象和类：对类的定义类似c语言有构造器（有继承关系的情况下，会做以下几步，1、设置子类的属性值，2、调用父类的构造器，3、还可以改变父类定义的属性值等等）和析构函数，创建类的时候不需要标准根类，与oc语言的区别。子类重写父类的方法需要用override标记。可以在类中定义属性的getter和setter方法，注意它的语法格式。同时swift中还多了一个willset和didset的方法概念。方法与函数有一个重要区别，方法的参数名（除了第一个参数以外的其他参数名）需要在调用的时候显示说明，最后提到如何处理变量的可选值，看起来感觉有些怪，这个还要多看看。</p>

<p>   函数和闭包；可以通过元组让一个函数返回多个值。并且函数参数可以是一个可变参数（numbers: Int&hellip;) ，在函数内部使用时类似于数组。函数可以嵌套，可以作为另一个函数的返回值，可以作为另一个函数的参数。
可以使用{}来创建一个匿名闭包，使用in将参数和返回值类型申明与闭包函数体进行连接。闭包在很多种情景下可以进行一些简化，如单个语句的闭包可以省略参数返回值类型申明以及in关键字，
可以使用参数位置$0 $1来直接引用参数。当闭包作为某个函数的最后一个参数时，可以直接跟在括号后面。</p>

<p>   控制流：相比于oc，有一些简化，如if后面的条件和for循环变量括号可以省略，但是语句体的大括号是必须的。有一个问题不是太明白，if语句后面必须跟一个布尔表达式，那为什么可以使用
if let name = optionalName ｛｝这样的类似语法处理值缺失的情况，其中var optionalName: String? = &ldquo;hello"是一个可选值。 swift中的switch相对于其他语言更加强大，可以支持任意类型的数据以及各种比较操作。并且它可以省略break语句，但是一定不能省略default。
可以使用for in 加上元组来遍历一个字典。在循环中可以使用1..&lt;n表示范围，但是不包括上界，使用1&hellip;n才包括上界</p>

<p>相关参考：</p>

<p><a href="http://special.csdncms.csdn.net/the-swift-programming-language-in-chinese/index.shtml">http://special.csdncms.csdn.net/the-swift-programming-language-in-chinese/index.shtml</a>  中文的</p>

<p><a href="https://itunes.apple.com/cn/book/the-swift-programming-language/id881256329?mt=11">https://itunes.apple.com/cn/book/the-swift-programming-language/id881256329?mt=11</a> 英文的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 学习笔记]]></title>
    <link href="http://amazinglf.github.io/blog/2015/04/15/git-xue-xi-bi-ji/"/>
    <updated>2015-04-15T11:09:27+08:00</updated>
    <id>http://amazinglf.github.io/blog/2015/04/15/git-xue-xi-bi-ji</id>
    <content type="html"><![CDATA[<p>1、理解git在本地常用的操作
  （1）git status命令的作用，即从查看本地仓库中出现了的修改和变化的角度去想，如添加、修改和删除文件的操作。比较常见的就是添加新的文件和修改仓库中的某个文件。该命令方便我们查看我们在本地所做的一些修改。 <br/>
   2）git本地操作的三个区域<br/>
         工作区  暂存区  版本库</p>

<p>   1、下面以新增加的文件为例，通过git status查看，它是Untracked files（未跟踪的文件）－》工作区。运行git add－》暂存区。再运行git commit－》本地版本库。
   如果在暂存区的时候对这个文件进行了修改，通过git status查看，该文件一个还在暂存区Changes to be committed，一个在工作区Changes not staged for commit。</p>

<p>   2、下面对修改本地仓库中的某个文件为例。通过status查看，它是Changes not staged for commit:－》工作区。运行git add－》暂存区，再运行git commit－》本地版本库。如果在暂存区对这个文件进行修改，结果与前面也是一样的。（即出现两个一样的文件）</p>

<p>   3、下面对删除本地仓库中的某个文件为例，如果是手工删除或者使用［rm 文件名］删除，通过status查看，Changes not staged for commit－》工作区。运行git rm 文件名－－》暂存区。再运行git commit－》本地版本库，该文件就不再纳入版本管理 git rm &ndash;cached readme.txt  要移除跟踪但不删除文件，即从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件比较适应  git mv file_from file_to  对文件改名</p>

<p>   最后总结，在工作区，文件有可能是新增加未跟踪的，有可能是修改未暂存，有可能是暂存后又修改未暂存的，有可能是跟踪后暂存然后修改未暂存的。开始总是会把未跟踪、未暂存、未提交这几种状态弄晕，其实只是表示一个状态，要与他实际的工作区域对应上，即从前面两个角度去分析。</p>

<p>2、远程仓库使用（注意与本地仓库进行区分）
   方式一：git clone git地址  克隆一个远程仓库到本地，会在本地当前目录下创建一个和远程仓库一样的文件夹，testlf。进入这个文件夹，就可以看到➜  testlf git:(master) . 用git管理项目的标识
   方式二：git init   对当前文件夹下的文件用git进行管理。会在当前文件夹下生成一个.git的隐藏文件。但是没有与任何远程仓库关联。那如何与远程仓库进行关联呢？
    1、git remote add pb git://github.com/paulboone/ticgit.git   //本操作含义：添加一个新的远程仓库，可以指定一个简单的名字,还没有进行任何关联，一般默认的仓库名是origin
     2、git fetch pb  / /抓取所有 Paul 上的数据。完成这个操作，Paul 的主干分支（master）已经完全可以在本地访问了，对应的名字是 pb/master
     3、你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新 （本地仓库和远程仓库的内容就相当于两个分支了，还要自己去尝试做）
    总结：不过我觉得一般开始管理远程仓库，都会先在远程上创建一个仓库create repository。然后将他clone到本地。在这个仓库对应的本地文件夹下创建项目，或者将要用git管理的工程复制到这个项目下，就可以对它add。。。等的操作进行管理和push到远程仓库了。并且本地所做的任何更改，都可以提交到远程仓库。</p>

<p>3、本地分支的新建与合并
     （1）基本命令
      git branch 分支名   //新建一个分支
      git checkout 分支名   //切换到相应分支
      注意：切换分支的时候最好保持一个清洁的工作区域。切换到下一个分支之前，保证工作区、暂存区的内容都已经提交。不然会混淆。并且它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支
      git branch   //不加任何参数，可以查看当前分支清单，分支前的＊号表示当前所在分支
      git branch -v //查看各个分支最后一个提交对象的信息
      git branch &ndash;merged  //查看已经合并的分支
      git branch – no-merged  //查看没有合并的分支
      git branch -d 分支名 //可以删除已经合并了的，如果删除没有合并的，会提示错误
      git branch -D 分支名  //强制删除没有合并的分支
     （2）分支指针
       master分支指针
       创建新的分支，就相当于创建了一个新的分支指针。
       head指针：切换分支时，指向你当前工作的分支
      画分支关系图的时候，主干分支横着画，创建的新分支竖着画，这样理解更清晰一些，如果一个分支下还有多个分支时，也可以竖着并行排列即可。
       （3）分支合并
       比较容易出现的一种情况即，在某个分支下新建一个分支后，做了很多次提交。而（从原来分支远程pull数据下来的时候，或者本地去做了一些修改的时候）原来的分支页进行了提交，并且可能与其他分支进行了merge操作，如下所示：</p>

<p>这里执行：
git merge iss53</p>

<p>  Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。
合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）。如下所示：</p>

<p>Git 作了合并，但没有提交，如果有冲突会提示。
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
并且停下来等你解决冲突，可以用 git status 查阅：并且会显示未解决冲突的具体文件。直接打开相应文件，用vim进行手动修改即可</p>

<p>可以看到 很多等号 隔开的到 很多尖括号 HEAD的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时所切换到的分支）中的内容。下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。
最后 尖括号和等号 这些行是需要手动删除的。下面是选其一的方式解决冲突</p>

<p>运行 git add 将把它们标记为已解决状态 ，再运行一次 git status 来确认所有冲突都已解决，就可以提交了。</p>

<p>  （4）长期分支理解</p>

<p>   master 分支中保留完全稳定的代码，即已经发布或即将发布的代码。 develop 或 next 的平行分支，专门用于后续的开发。一旦进入某种稳定状态，便可以把它合并到 master 里。
     下面是书本上的一个例子，起先我们在 master 工作到 C1，然后开始一个新分支 iss91 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支 iss91v2，干到 C8 的时候，又回到主干 master 中提交了 C9 和 C10，再回到iss91v2 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 master 的最新提交 C10 处开了个新的分支 dumbidea 做些试验。</p>

<p>   对于从之前 C4 的地方又分出一个分支 iss91v2，我一直都不太明白，是怎么回到分支的某个commit的。原来git还有一个很高级的命令
<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000">http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000</a></p>

<p> （5）版本回退命令
   git reset &ndash;hard HEAD^
 因为Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交（通过git log／git log &ndash;pretty=oneline），
可以查看提交的commit号。上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。
回退到相应版本之后，查看相应文件，就会发现也会回到之前修改的状态。通过git log查看版本库也会发现。回退版本之前的版本都没有了。
      1、如果想回到之前最新的版本，怎么办，
只要命令行终端没有关闭，找到之前git log查看的相应版本的commitid，然后使用下面的命令即可
git reset &ndash;hard 命令号（取前几位就可以了），然后再查看相应文件，发现又回到最新的了。
2、如果关闭电脑，关闭命令行终端后，想回到之前最新的版本，怎么办
使用git reflog  就可以查看每一次命令的记录，然后就可以找到相应版本的commitid号</p>

<p>   总结
   HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset &ndash;hard commit_id。
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>

<p>5、远程分支的理解和使用
远程分支的表示形式： (远程仓库名)/(分支名)
通过下面的图对远程分支和本地分支进行一个对比，同时与远程仓库和本地仓库的概念区分开。</p>

<p>5、创建远程分支方法
      （1）我是在本地执行如下命令时，git push origin master:new-remote-branch，如果远程没有一个名为new-remote-branch的分支，系统就会自动创建一个origin/new-remote-branch的远程分支了。
git push (远程仓库名)  (本地分支名) : (远程分支名)
 （可以将本地的某个分支提交到远程的任意一个分支，这个分支就默认跟踪了这个远程分支），
➜  gcdTestForGit git:(master) git push origin master:new-remote-branch
Counting objects: 4, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 353 bytes | 0 bytes/s, done.
Total 4 (delta 2), reused 0 (delta 0)
remote:
remote: Create pull request for new-remote-branch:
remote:   git分支
remote:
To git地址
 * [new branch]      master -> new-remote-branch
➜  gcdTestForGit git:(master)
   （2）跟踪某个远程分支 方法：  从远程分支 checkout 出对应的本地分支，即相当于在本地创建一个与远程一样的分支，进行跟踪
      创建方式：
      git checkout -b master origin/master   ／／从远程分支新建并切换到master 本地分支，其内容同远程分支 origin/master 一致，这样你就可以在里面继续开发了   。其实这些在git clone  的时候git都给我们做好了。但是如果是其他git add 的远程分支，我们就需要手动去做这些操作。
➜  gcdTestForGit git:(master) git checkout -b test-link-remote origin/new-remote-branch<br/>
Branch test-link-remote set up to track remote branch new-remote-branch from origin.
Switched to a new branch &lsquo;test-link-remote&rsquo;
➜  gcdTestForGit git:(test-link-remote)
      git checkout &ndash;track origin/master    ／／1.6.2 以上版本的 Git，对上面第一种创建方式进行简化。要为本地分支设定不同于远程分支的名字，就使用第一种方式换个名字即可。
      作用：1、跟踪分支里输入 git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。
           2、同样，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。
      注意：如果要在特定的远程分支中工作，提交数据，必须先按照上面的方式在本地先跟踪这个分支（比如development分支），然后在这个本地分支下再新建分支（如bugfix/mybranch，进行操作，完成后提交到远程的bugfix/mybranch分支，最后在远程合并到development分支
     实例操作：
      我们可以通过创建很多个本地分支来追踪某个远程分支。然后每次push，都自动提交到这个远程分支下。最后master分支可以将远程分支合并。
如下图所示。
test2-link-remote和test-link-remote是跟踪远程分支origin／new-remote-branch 的两个本地分支。当本地分支test2-link-remote   push到跟踪的远程分支上时，会提示本地分支test-link-remote落后远程分支一个版本，</p>

<p>这时可以切换到test-link-remote分支下，执行pull操作，就可以保持他们一致，如下图所示：</p>

<p>合并两个远程分支
如上面例子所示：合并origin/master   与  origin/new-remote-branch .解决相应冲突即可(解决冲突的方法见上面）
➜  gcdTestForGit git:(master) git merge origin/new-remote-branch
Auto-merging gcdTestForGit/test1.txt
CONFLICT (content): Merge conflict in gcdTestForGit/test1.txt
Auto-merging gcdTestForGit/test.txt
CONFLICT (content): Merge conflict in gcdTestForGit/test.txt
Automatic merge failed; fix conflicts and then commit the result.
➜  gcdTestForGit git:(master) ✗
具体解决冲突如下：
➜  gcdTestForGit git:(master) ✗ git status
On branch master
Your branch is up-to-date with &lsquo;origin/master&rsquo;.
You have unmerged paths.
  (fix conflicts and run &ldquo;git commit&rdquo;)</p>

<p>Unmerged paths:
  (use &ldquo;git add <file>&hellip;&rdquo; to mark resolution)</p>

<p> both modified:   test.txt
 both modified:   test1.txt</p>

<p>no changes added to commit (use &ldquo;git add&rdquo; and/or &ldquo;git commit -a&rdquo;)
➜  gcdTestForGit git:(master) ✗ vim test.txt
➜  gcdTestForGit git:(master) ✗ vim test1.txt
➜  gcdTestForGit git:(master) ✗ git status
On branch master
Your branch is up-to-date with &lsquo;origin/master&rsquo;.
You have unmerged paths.
  (fix conflicts and run &ldquo;git commit&rdquo;)</p>

<p>Unmerged paths:
  (use &ldquo;git add <file>&hellip;&rdquo; to mark resolution)</p>

<p> both modified:   test.txt
 both modified:   test1.txt</p>

<p>no changes added to commit (use &ldquo;git add&rdquo; and/or &ldquo;git commit -a&rdquo;)
➜  gcdTestForGit git:(master) ✗ git add .
➜  gcdTestForGit git:(master) ✗ git status
On branch master
Your branch is up-to-date with &lsquo;origin/master&rsquo;.
All conflicts fixed but you are still merging.
  (use &ldquo;git commit&rdquo; to conclude merge)</p>

<p>Changes to be committed:</p>

<p> modified:   test.txt
 modified:   test1.txt</p>

<p>➜  gcdTestForGit git:(master) ✗ git commit -m &lsquo;submit-git-test-10&rsquo;
[master 95552e2] submit-git-test-10
➜  gcdTestForGit git:(master) gi status
zsh: command not found: gi
➜  gcdTestForGit git:(master) git status
On branch master
Your branch is ahead of &lsquo;origin/master&rsquo; by 3 commits.
  (use &ldquo;git push&rdquo; to publish your local commits)
nothing to commit, working directory clean
➜  gcdTestForGit git:(master) git push origin master
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 545 bytes | 0 bytes/s, done.
Total 5 (delta 2), reused 0 (delta 0)
To git分支  master -> master
➜  gcdTestForGit git:(master)
远程分支合并后的结果如下：</p>

<p>删除远程分支
git push [远程名] :[分支名]    ／／其实它是省略了《git push [远程名] [本地分支]:[远程分支]》命令中的本地分支。即提取一个空白的本地分支到远程分支。所有一定要注意这个两个命令的区别。使用git push命令做提交操作时一定要注意，如果写了（：），一定要加本地分支名</p>

<p>问题：如果某个本地分支没有与远程分支关联，（在master分支下，好像默认跟踪的master，还是），可以push到别的远程仓库吗？
如下：在master下创建一个分支，在本地做修改并且做了commit提交，但是没有push。
然后把它push到别的远程分支会是什么情况？
➜  gcdTestForGit git:(test-local-branch) git push origin test-local-branch:new-remote-branch
Counting objects: 4, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (4/4), 363 bytes | 0 bytes/s, done.
Total 4 (delta 3), reused 0 (delta 0)
remote:
remote: Create pull request for new-remote-branch:
remote:   git分支
remote:
To git地址
   103f55f..852a6ea  test-local-branch -> new-remote-branch
➜  gcdTestForGit git:(test-local-branch)
结果：test-local-branch分支变成了跟踪new-remote-branch远程分支的一个本地分支
并且切换到远程分支new-remote-branch中，可以看到在本地test-local-branch分支中做的修改，说明push成功了。
结论：在本地创建一个分支的时候，（跟踪某个远程分支的作用是可以fetch／pull这个远程分支的数据，不跟踪貌似也能拉取它的数据，所以我觉得本地分支和远程分支在push之前好像没有很大联系），在push操作之前，一定要对远程分支进行fetch／pull的操作拉取新的更新数据，然后push。
好像push fetch pull的时候都不会出现冲突（push就是把本地的覆盖远程的，fetch／pull远程覆盖本地的），只有merge的时候才会有冲突。</p>

<p>所以在做项目时应该是每个人创建属于自己的远程分支（所以push都只覆盖自己），然后某个人去把这个远程分支进行merge时再去解决冲突。最后可能就把merge后的分支再与主远程分支merge
下面这篇博客讲了多人协作开发中git在不同场景下的使用，可以多看看，多试着练习一下，博客最后有人提了一个问题，其实也是我不太懂的。就是怎么建远程分支，好像我前面都是建本地分支时设置一个远程分支，然后就自动生成， 问了一下我们项目时开一个task的时候，可以在那个网页上建远程分支就可以了。
<a href="http://limboy.me/tech/2011/02/25/git-workflow-with-blog-demo.html">http://limboy.me/tech/2011/02/25/git-workflow-with-blog-demo.html</a></p>

<p>下面是我做的一次练习测试，加深我对git多人协作开发流程的理解</p>

<p>在当前分支下，提交多次。并且push到对应的远程分支</p>

<p>git:(new-remote-branch) git push origin new-remote-branch。结果如下所示</p>

<p>然后利用版本回退，回到前面的第二个commit
git:(new-remote-branch) git reset &ndash;hard HEAD~2</p>

<p>此时还会提示你要git pull远程上的commit，但是你想把前面的两个commit都删除。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git status
On branch new-remote-branch
Your branch is behind &lsquo;origin/new-remote-branch&rsquo; by 2 commits, and can be fast-forwarded.
  (use &ldquo;git pull&rdquo; to update your local branch)
nothing to commit, working directory clean</p>

<p>这时又在这里做了多次commit。即出现分支的分化（分叉），直接push的话，git会默认对这些分支进行一个merge。如果有冲突就会出现错误，不知道是不是的。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) vim test1.txt
➜  gcdTestForGit git:(new-remote-branch) ✗ git add .
➜  gcdTestForGit git:(new-remote-branch) ✗ git commit -m &lsquo;submit-08-14-06&rsquo;
[new-remote-branch cfb560b] submit-08-14-06
 1 file changed, 1 insertion(+), 1 deletion(-)</p>

<p>如下图所示</p>

<p>再做一次和前面一样的commit操作，得到如下</p>

<p>其实上面的图显示的告诉你，可以git merge来合并。但是如果我直接push的话，看一下会出现什么结果.果然出错了。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git push origin new-remote-branch
To git地址
 ! [rejected]        new-remote-branch -> new-remote-branch (non-fast-forward)
error: failed to push some refs to &lsquo;git地址&rsquo;
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: &lsquo;git pull &hellip;&rsquo;) before pushing again.
hint: See the &lsquo;Note about fast-forwards&rsquo; in &lsquo;git push &ndash;help&rsquo; for details.</p>

<p>然后运行git status，提示你要先pull</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git status
On branch new-remote-branch
Your branch and &lsquo;origin/new-remote-branch&rsquo; have diverged,
and have 2 and 2 different commits each, respectively.
  (use &ldquo;git pull&rdquo; to merge the remote branch into yours)
nothing to commit, working directory clean
git pull之后就会告诉你有哪些冲突，然后解决冲突后就可以了。</p>

<p>➜  gcdTestForGit git:(new-remote-branch) git pull
Auto-merging gcdTestForGit/test1.txt
CONFLICT (content): Merge conflict in gcdTestForGit/test1.txt
Automatic merge failed; fix conflicts and then commit the result.</p>

<p>最后解决冲突，然后commit push之后，就可以了</p>

<p>➜  gcdTestForGit git:(new-remote-branch) ✗ vim test1.txt
➜  gcdTestForGit git:(new-remote-branch) ✗ git add .
➜  gcdTestForGit git:(new-remote-branch) ✗ git commit -m &lsquo;submit-08-14-08&rsquo;
[new-remote-branch 3dd204d] submit-08-14-08
➜  gcdTestForGit git:(new-remote-branch) git push origin new-remote-branch
Counting objects: 12, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (12/12), 1.00 KiB | 0 bytes/s, done.
Total 12 (delta 9), reused 0 (delta 0)
remote:
remote: Create pull request for new-remote-branch:
remote:   git分支
remote:
To git地址
   c66c1bc..3dd204d  new-remote-branch -> new-remote-branch</p>

<p>但是如果想强制将分叉本地分支覆盖掉远程分支上。而submit－08-14-04和submit－08-14－05两次commit的操作都删除的话，使用git push origin new-remote-branch。即加一个－f的参数。就可以不记性pull然后解决冲突了。</p>

<p>总结：通过上面的实验，让我明白了在一个分支上一直commit push的话，直接覆盖前面的。只有当在这个分支上（如回退到某个分岔点）出现分岔的时候才需要merge等的操作，就可能需要解决冲突。所以很多人在一个远程分支上工作的时候。一般如果有人push了，则你在本地想要push
的时候，先运行git status，一般就会告诉你先git pull，然后如果没有冲突你再push就可以了。如果是你一个人在远程分支上工作貌似就没关系。</p>

<p>git rebase的理解：修改当前分支的基底分支，在基底分支上重演一遍分支中所做的修改，这个命令执行后不会出现马上要解决冲突，因为它还是生成了一个分支，只有从新的基底分支merge这个分支的时候才可能出现要解决冲突。</p>

<p>［第一部分］
<a href="http://blog.csdn.net/u010520912/article/details/18993001">http://blog.csdn.net/u010520912/article/details/18993001</a>
创建github账号及上传代码的步骤
github账号地址
<a href="https://github.com/amyliangfang/lf/blob/master/c-01/c-01">https://github.com/amyliangfang/lf/blob/master/c-01/c-01</a>
具体步骤：
注册github账号－使用ssh密钥认证－创建本地仓库并上传代码到github</p>

<p>参考书籍：
<a href="http://git-scm.com/book/en/v2">http://git-scm.com/book/en/v2</a></p>

<p><a href="http://pcottle.github.io/learnGitBranching/">http://pcottle.github.io/learnGitBranching/</a></p>
]]></content>
  </entry>
  
</feed>
